<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OPTICAL SUITE // LAVAL SOFTWARE</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #050510;
            --glass: rgba(20, 20, 35, 0.95);
            --glass-border: rgba(255, 255, 255, 0.1);
            --neon-cyan: #00f3ff;
            --neon-pink: #bc13fe;
            --neon-green: #0f0;
            --neon-orange: #ff9d00;
            --text-main: #e0e0e0;
            --text-dim: #8b9bb4;
        }

        body {
            background-color: var(--bg-dark);
            background-image: 
                linear-gradient(rgba(0, 243, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 243, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            color: var(--text-main);
            font-family: 'Rajdhani', sans-serif;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-x: hidden;
        }

        .main-wrapper { width: 100%; max-width: 1400px; display: flex; flex-direction: column; gap: 20px; }
        .nav-tabs { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; }
        .tab-btn {
            background: rgba(0,0,0,0.5); border: 1px solid var(--glass-border); color: var(--text-dim);
            padding: 15px 30px; font-family: 'Orbitron'; font-size: 1rem; cursor: pointer; transition: 0.3s;
            clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
            text-align: center;
        }
        .tab-btn.active { background: var(--neon-cyan); color: #000; font-weight: bold; box-shadow: 0 0 20px rgba(0, 243, 255, 0.3); }

        .interface-container {
            background: var(--glass); backdrop-filter: blur(20px); border: 1px solid var(--glass-border);
            border-radius: 4px; box-shadow: 0 0 50px rgba(0, 0, 0, 0.9); display: none;
            grid-template-columns: 360px 1fr; overflow: hidden; min-height: 850px;
            clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
        }
        .interface-container.active { display: grid; }
        #course.interface-container.active { display: block; padding: 40px; overflow-y: auto; }

        .controls { padding: 30px; border-right: 1px solid var(--glass-border); background: rgba(0, 0, 0, 0.3); display: flex; flex-direction: column; gap: 15px; overflow-y: auto; z-index: 2; }
        .brand { font-family: 'Orbitron', sans-serif; font-size: 1.5rem; color: #fff; border-bottom: 2px solid var(--neon-cyan); padding-bottom: 15px; margin-bottom: 10px; }
        .brand span { color: var(--neon-pink); }
        .input-group label { display: flex; justify-content: space-between; font-size: 0.8rem; color: var(--text-dim); margin-bottom: 5px; text-transform: uppercase; align-items: center; }
        .input-group input, .input-group select { width: 100%; background: rgba(255, 255, 255, 0.05); border: 1px solid var(--glass-border); color: #fff; padding: 12px; font-family: 'Orbitron'; font-size: 1rem; }
        .input-group input:disabled { background: rgba(0,0,0,0.5); color: #555; cursor: not-allowed; }
        .mode-switch-mini { display: flex; font-size: 0.7rem; gap: 5px; cursor: pointer; }
        .mode-switch-mini span { color: var(--text-dim); padding: 2px 5px; border-radius: 2px; transition: 0.3s; }
        .mode-switch-mini span.active { color: #000; background: var(--neon-cyan); font-weight: bold; }
        .btn-action { background: linear-gradient(90deg, var(--neon-cyan), #0088ff); color: #000; border: none; padding: 15px; font-family: 'Orbitron'; font-weight: bold; cursor: pointer; margin-top: auto; text-transform: uppercase; }
        .btn-action:hover { box-shadow: 0 0 20px var(--neon-cyan); letter-spacing: 2px; }
        .btn-pdf { background: #fff; color: #000; border: none; padding: 15px; font-family: 'Orbitron'; font-weight: bold; cursor: pointer; margin-top: 10px; text-transform: uppercase; }
        .btn-pdf:hover { background: #eee; box-shadow: 0 0 15px #fff; }
        .btn-auto { background: transparent; border: 1px solid var(--neon-pink); color: var(--neon-pink); padding: 10px; font-family: 'Orbitron'; font-size: 0.8rem; cursor: pointer; width: 100%; transition: 0.3s; }
        .btn-auto:hover { background: var(--neon-pink); color: #fff; box-shadow: 0 0 15px var(--neon-pink); }
        .auto-group { display: flex; gap: 10px; align-items: flex-end; margin-bottom: 15px; }
        .input-small { width: 80px !important; text-align: center; }

        .results-panel { padding: 40px; position: relative; background: radial-gradient(circle at top right, rgba(0,50,100,0.15), transparent); overflow-y: auto; display: flex; flex-direction: column; }
        .course-content { max-width: 900px; margin: 0 auto; color: #e0e0e0; line-height: 1.6; }
        .course-header { display: flex; justify-content: space-between; align-items: flex-start; border-bottom: 2px solid var(--neon-cyan); padding-bottom: 20px; margin-bottom: 40px; }
        .course-title { font-family: 'Orbitron'; font-size: 2.5rem; color: #fff; line-height: 1.1; }
        .course-author { color: var(--text-dim); font-family: 'Rajdhani'; font-size: 1.2rem; margin-top: 5px; font-style: italic; }
        .chapter { margin-bottom: 50px; background: rgba(255,255,255,0.02); padding: 30px; border-radius: 8px; border-left: 4px solid var(--neon-pink); }
        .chapter h2 { font-family: 'Orbitron'; color: var(--neon-cyan); margin-top: 0; }
        .chapter h3 { color: var(--neon-orange); margin-top: 20px; }
        .formula-box { background: rgba(0,0,0,0.5); padding: 20px; border-radius: 8px; font-family: 'Courier New', monospace; margin: 20px 0; border: 1px solid var(--glass-border); text-align: center; font-size: 1.1rem; color: var(--neon-green); }
        .example-box { background: rgba(255, 157, 0, 0.1); border: 1px dashed var(--neon-orange); padding: 20px; border-radius: 8px; }

        .blueprint-wrapper, .viz-wrapper { position: relative; width: 100%; background: #ffffff; border: 1px solid var(--glass-border); margin-bottom: 20px; overflow: hidden; }
        .blueprint-wrapper { height: 450px; }
        .viz-wrapper { height: 350px; } 
        canvas { display: block; cursor: grab; width: 100%; height: 100%; }
        canvas:active { cursor: grabbing; }
        
        .cam-controls { 
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 5px; background: rgba(255,255,255,0.9); padding: 5px; 
            border-radius: 4px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 5;
        }
        .cam-btn {
            background: #fff; border: 1px solid #ccc; color: #333; 
            font-family: 'Orbitron'; font-size: 0.7rem; padding: 5px 10px; cursor: pointer; transition: 0.2s;
        }
        .cam-btn:hover { background: var(--neon-cyan); color: #000; border-color: var(--neon-cyan); }
        
        .zoom-controls { position: absolute; bottom: 20px; right: 20px; display: flex; gap: 5px; }
        .zoom-btn { width: 30px; height: 30px; background: rgba(0,0,0,0.1); color: #000; border: 1px solid #000; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .zoom-btn:hover { background: #000; color: #fff; }
        .view-tabs { display: flex; gap: 10px; margin-bottom: 10px; }
        .view-tab { padding: 5px 15px; background: rgba(255,255,255,0.1); cursor: pointer; font-family: 'Orbitron'; font-size: 0.8rem; color: var(--text-dim); border: 1px solid transparent; }
        .view-tab.active { background: var(--neon-pink); color: white; border-color: var(--neon-pink); }

        .arch-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .mirror-card { background: rgba(255,255,255,0.02); border: 1px solid var(--glass-border); padding: 25px; }
        .mirror-card h3 { margin: 0 0 20px 0; font-family: 'Orbitron'; font-size: 1rem; color: var(--text-dim); border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:10px;}
        .res-val { font-family: 'Orbitron'; color: #fff; font-size: 1.2rem; text-align: right; }
        .result-row { display: flex; justify-content: space-between; margin-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 5px; font-size: 0.9rem;}
        .data-table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        .data-table th { text-align: left; color: var(--text-dim); padding: 10px; border-bottom: 1px solid var(--neon-cyan); }
        .data-table td { padding: 10px; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .footer-brand { position: fixed; bottom: 10px; right: 20px; font-family: 'Orbitron'; font-size: 0.7rem; color: rgba(255,255,255,0.3); }
        #an-info { margin-bottom: 20px; display: flex; gap: 20px; font-size: 0.9rem; color: var(--text-dim); align-items: center;}
        #an-info span { color: #fff; font-family: 'Orbitron'; margin-left: 5px; margin-right: 15px;}
        .mode-switch { display: flex; background: rgba(0,0,0,0.5); padding: 4px; border-radius: 4px; margin-bottom: 10px; }
        .mode-option { flex: 1; text-align: center; padding: 8px 4px; font-size: 0.7rem; cursor: pointer; color: var(--text-dim); font-family: 'Orbitron'; white-space: nowrap; }
        .mode-option.active { background: var(--neon-pink); color: white; font-weight: bold; }
    </style>
</head>
<body>

<div class="main-wrapper">
    <div class="nav-tabs">
        <div class="tab-btn active" onclick="switchTab('analyzer')">ANALYSEUR CAUSTIQUE</div>
        <div class="tab-btn" onclick="switchTab('architect')">ARCHITECTE OPTIQUE</div>
        <div class="tab-btn" onclick="switchTab('course')">COURS & THÃ‰ORIE</div>
    </div>

    <!-- ANALYZER -->
    <div id="analyzer" class="interface-container active">
        <div class="controls">
            <div class="brand">CAUSTIQUE <span>v47</span></div>
            <div class="input-group"><label>Type</label><select id="an-type" onchange="updateAnalyzerK(); runAnalyzer()"><option value="parabola" selected>Parabole</option><option value="hyperbola">Hyperbole</option><option value="sphere">SphÃ¨re</option><option value="ellipse">Ellipse</option><option value="custom">Perso</option></select></div>
            <div class="input-group"><label>DiamÃ¨tre (mm)</label><input type="number" id="an-diameter" value="300" oninput="runAnalyzer()"></div>
            <div class="input-group"><label>Ã‰paisseur (mm)</label><input type="number" id="an-thickness" value="35" oninput="runAnalyzer()"></div>
            <div class="input-group"><label>Trou Central (mm)</label><input type="number" id="an-hole" value="0" placeholder="0" oninput="runAnalyzer()"></div>
            <div class="input-group"><label>COURBURE <div class="mode-switch-mini"><span id="mode-an-R" class="active" onclick="setAnMode('R')">RAYON</span><span id="mode-an-F" onclick="setAnMode('F')">FOCALE</span></div></label><input type="number" id="an-curvature-val" value="6200" step="0.1" oninput="runAnalyzer()"></div>
            <div class="input-group"><label>Constante (K)</label><input type="number" id="an-kfactor" value="-1" step="0.0001" disabled oninput="runAnalyzer()"></div>
            <label style="color:var(--text-dim); font-size:0.8rem; margin-top:10px; display:block;">GÃ‰NÃ‰RATEUR DE ZONES</label>
            <div class="auto-group"><div style="flex:1"><label style="font-size:0.6rem">NB. ZONES</label><input type="number" id="an-nb-zones" class="input-small" placeholder="Auto"></div><button class="btn-auto" onclick="autoCalcZones()">CALCULER ZONES</button></div>
            <div class="input-group"><label>Liste Rayons (mm)</label><input type="text" id="an-zones" value="50, 100, 140, 200" onchange="runAnalyzer()"></div>
        </div>
        <div class="results-panel">
            <div id="an-info"><div>F/D: <span id="an-fd">-</span></div><div>Zone Max: <span id="an-maxw" style="color:var(--neon-pink)">-</span></div><div style="margin-left:auto;">POIDS EST. (Zerodur): <span id="an-weight" style="color:var(--neon-green); font-size:1.2rem;">- kg</span></div></div>
            <div class="view-tabs"><div class="view-tab active" onclick="setVizMode('an','2d')" id="tab-an-2d">VUE 2D (FACE + COUPE)</div><div class="view-tab" onclick="setVizMode('an','3d')" id="tab-an-3d">VUE 3D</div></div>
            <div class="viz-wrapper">
                <canvas id="visualizer"></canvas>
                <div id="container3d_an" style="width:100%; height:100%; display:none;"></div>
                <div class="cam-controls" id="cam-an" style="display:none;">
                    <button class="cam-btn" onclick="resetCamera('an', 'default')">RECADRER</button>
                    <button class="cam-btn" onclick="resetCamera('an', 'front')">FACE</button>
                    <button class="cam-btn" onclick="resetCamera('an', 'side')">PROFIL</button>
                    <button class="cam-btn" onclick="resetCamera('an', 'back')">DOS</button>
                </div>
            </div>
            <table class="data-table"><thead><tr><th>ZONE</th><th>RAYON (S)</th><th>PROF. (Z)</th><th>AXIAL (Y)</th><th>TRANSV. (X)</th></tr></thead><tbody id="an-results"></tbody></table>
        </div>
    </div>

    <!-- ARCHITECT -->
    <div id="architect" class="interface-container">
        <div class="controls">
            <div class="brand">ARCHITECT <span>PRO</span></div>
            <div class="input-group"><label>Architecture</label><select id="arch-type" onchange="updateArchUI()"><option value="newton">Newton</option><option value="cassegrain">Cassegrain</option><option value="dk">Dall-Kirkham</option><option value="rc" selected>Ritchey-ChrÃ©tien</option><option value="sct">SCT</option></select></div>
            <div class="input-group"><label>DiamÃ¨tre (D)</label><input type="number" id="arch-D" value="300"></div>
            <div class="input-group"><label>Focale SystÃ¨me</label><input type="number" id="arch-F" value="4500" title="CalculÃ© automatiquement en mode manuel"></div>
            <div class="input-group"><label>Back Focus</label><input type="number" id="arch-B" value="300"></div>
            
            <div id="calc-mode-container">
                <div class="mode-switch">
                    <div class="mode-option active" id="mode-f1" onclick="setCalcMode('f1')">FIXER F1</div>
                    <div class="mode-option" id="mode-sep" onclick="setCalcMode('sep')">FIXER SEP</div>
                    <div class="mode-option" id="mode-auto" onclick="setCalcMode('auto')">AUTO</div>
                    <div class="mode-option" id="mode-free" onclick="setCalcMode('free')">MANUEL</div>
                </div>
            </div>
            
            <div class="input-group"><label>Focale Primaire <span id="lock-f1">ðŸ”’</span></label><input type="number" id="arch-F1" value="900"></div>
            <div class="input-group"><label>SÃ©paration <span id="lock-sep" style="display:none">ðŸ”’</span></label><input type="number" id="arch-Sep" value="650" disabled></div>
            <button class="btn-action" onclick="runArchitect()">CALCULER & DESSINER</button>
            <div class="pdf-group" style="margin-top:20px; border-top:1px solid rgba(255,255,255,0.1); padding-top:20px;"><div class="input-group"><label>Nom du Projet</label><input type="text" id="project-name" placeholder="Ex: Mon DK 300"></div><button class="btn-pdf" onclick="downloadPDF()">TÃ‰LÃ‰CHARGER LE PLAN (PDF)</button></div>
        </div>
        <div class="results-panel">
            <div class="view-tabs"><div class="view-tab active" onclick="setVizMode('arch','2d')" id="tab-arch-2d">PLAN 2D</div><div class="view-tab" onclick="setVizMode('arch','3d')" id="tab-arch-3d">SYSTÃˆME 3D</div></div>
            <div class="blueprint-wrapper">
                <canvas id="blueprint-canvas"></canvas>
                <div id="container3d_arch" style="width:100%; height:100%; display:none;"></div>
                <div class="zoom-controls" id="zoom-controls-2d"><div class="zoom-btn" onclick="zoomBlueprint(0.1)">+</div><div class="zoom-btn" onclick="zoomBlueprint(-0.1)">-</div><div class="zoom-btn" onclick="resetZoom()">R</div></div>
                <div class="cam-controls" id="cam-arch" style="display:none;">
                    <button class="cam-btn" onclick="resetCamera('arch', 'default')">RECADRER</button>
                    <button class="cam-btn" onclick="resetCamera('arch', 'front')">AVANT</button>
                    <button class="cam-btn" onclick="resetCamera('arch', 'side')">COTÃ‰</button>
                </div>
            </div>
            <div style="display:flex; justify-content:space-between; margin-bottom:20px; border-bottom:1px solid var(--glass-border); padding-bottom:10px;">
                <div><div style="font-size:0.8rem; color:var(--text-dim)">OUVERTURE</div><div style="font-family:'Orbitron'; font-size:1.2rem; color:#fff" id="res-fd">-</div></div>
                <div><div style="font-size:0.8rem; color:var(--text-dim)">GRANDISSEMENT</div><div style="font-family:'Orbitron'; font-size:1.2rem; color:#fff" id="res-mag">-</div></div>
                <div><div style="font-size:0.8rem; color:var(--text-dim)">OBSTRUCTION</div><div style="font-family:'Orbitron'; font-size:1.2rem; color:#fff" id="res-obst">-</div></div>
                <div><div style="font-size:0.8rem; color:var(--text-dim)">DIAMÃˆTRE PUR</div><div style="font-family:'Orbitron'; font-size:1.2rem; color:var(--neon-cyan)" id="res-d-eff">-</div></div>
                <div><div style="font-size:0.8rem; color:var(--text-dim)">RÃ‰SOLUTION</div><div style="font-family:'Orbitron'; font-size:1.2rem; color:var(--neon-pink)" id="res-resol">-</div></div>
            </div>
            <div class="arch-grid">
                <div class="mirror-card"><h3 style="color:var(--neon-orange)">MIROIR PRIMAIRE</h3><div class="result-row"><span>Rayon R1</span><div class="res-val" id="res-r1">-</div></div><div class="result-row"><span>Focale F1</span><div class="res-val" id="res-f1-out">-</div></div><div class="result-row"><span>Constante K1</span><div class="res-val" id="res-k1">-</div></div><div class="result-row"><span>Forme</span><div class="res-val" id="res-shape1" style="font-size:0.8rem">-</div></div><div class="result-row"><span>Trou Central (Min)</span><div class="res-val" id="res-hole" style="color:var(--neon-pink)">-</div></div></div>
                <div class="mirror-card" id="sec-card"><h3 style="color:var(--neon-green)">MIROIR SECONDAIRE</h3><div class="result-row"><span>Rayon R2</span><div class="res-val" id="res-r2">-</div></div><div class="result-row"><span>SÃ©paration d</span><div class="res-val" id="res-sep-out">-</div></div><div class="result-row"><span>Constante K2</span><div class="res-val" id="res-k2">-</div></div><div class="result-row"><span>Forme</span><div class="res-val" id="res-shape2" style="font-size:0.8rem">-</div></div><div class="result-row"><span>DiamÃ¨tre Optique</span><div class="res-val" id="res-d2">-</div></div></div>
            </div>
        </div>
    </div>

    <!-- COURSE -->
    <div id="course" class="interface-container">
        <div class="course-content" id="course-text">
            <div class="course-header"><div><div class="course-title">COURS D'OPTIQUE APPLIQUÃ‰E</div><div class="course-author">RÃ©digÃ© par Ludovic Laval</div></div><button class="btn-pdf" style="width:auto; margin:0;" onclick="downloadCoursePDF()">TÃ‰LÃ‰CHARGER LE COURS (PDF)</button></div>
            <div class="chapter">
                <h2>1. LE TEST DE LA CAUSTIQUE</h2>
                <h3>Le ProblÃ¨me de l'Aberration SphÃ©rique</h3>
                <p>Un miroir sphÃ©rique focalise tous les rayons en un point unique (le centre de courbure). Mais pour un tÃ©lescope, nous utilisons souvent des formes <strong>Paraboliques</strong> ou <strong>Hyperboliques</strong> pour corriger les images venues de l'infini.</p>
                <p>Ces miroirs asphÃ©riques n'ont pas un rayon de courbure constant. Le "centre" varie selon la zone du miroir. L'ensemble de ces centres forme une courbe appelÃ©e <strong>La Caustique</strong>.</p>
                
                <h3>La MÃ©thode Platzeck-Gaviola</h3>
                <p>Ce logiciel utilise les Ã©quations dÃ©rivÃ©es par <em>Cornejo & Malacara (1978)</em> pour calculer oÃ¹ placer l'appareil de contrÃ´le (Foucault) pour chaque zone du miroir.</p>
                
                <div class="formula-box">DonnÃ©es d'EntrÃ©e : R (Rayon), K (Constante), S (Zone)</div>
            </div>

            <div class="chapter">
                <h2>2. LES FORMULES MATHÃ‰MATIQUES</h2>
                <p>Voici comment le logiciel fonctionne "sous le capot". Ces Ã©quations sont les solutions analytiques exactes.</p>

                <h3>Ã‰tape 1 : La Courbure (c)</h3>
                <div class="formula-box">c = 1 / R</div>

                <h3>Ã‰tape 2 : La FlÃ¨che (z) - "Sagitta"</h3>
                <p>C'est la profondeur du miroir Ã  la hauteur S.</p>
                <div class="formula-box">z = (c * SÂ²) / (1 + âˆš(1 - (K+1) * cÂ² * SÂ²))</div>

                <h3>Ã‰tape 3 : CoordonnÃ©es de la Caustique (X, Y)</h3>
                <p>Le logiciel calcule deux valeurs. <strong>Y</strong> est la position longitudinale (avant/arriÃ¨re) et <strong>X</strong> est la position transversale (latÃ©rale).</p>
                <div class="formula-box">Terme A = c * z * (K + 1)<br><br>Y = -K * z * [3 + A * (A - 3)]<br>X = -2 * S * c * K * z * [2 + A * (A - 3)] / (1 - A)</div>
            </div>
            
            <div class="chapter">
                <h2>3. EXEMPLE DE CALCUL Ã€ LA MAIN</h2>
                <div class="example-box">
                    <p>Prenons un miroir standard : <strong>R = 6200 mm, K = -1, S = 250 mm</strong></p>
                    <p><strong>1. Calcul de c :</strong> c = 1 / 6200 â‰ˆ 0.00016129</p>
                    <p><strong>2. Calcul de z :</strong> Pour K = -1, formule simplifiÃ©e : z = c * SÂ² / 2 = 250Â² / (2 * 6200) â‰ˆ <strong>5.0403 mm</strong></p>
                    <p><strong>3. Calcul de A :</strong> Comme K+1 = 0, alors <strong>A = 0</strong>.</p>
                    <p><strong>4. Calcul de Y :</strong> Y = -(-1) * 5.0403 * [3 + 0] = <strong>15.1209 mm</strong></p>
                    <p><strong>5. Calcul de X :</strong> X = 500 * (1/6200) * 5.0403 * 2 â‰ˆ <strong>0.8129 mm</strong></p>
                </div>
            </div>

            <div class="chapter">
                <h2>4. MODULE ARCHITECTE OPTIQUE</h2>
                <p>Ce module utilise la thÃ©orie de Schwarzschild du 3Ã¨me ordre pour calculer les miroirs.</p>
                <h3>Dall-Kirkham</h3>
                <p>Pour un DK, on impose un secondaire sphÃ©rique (<span class="variable">K2=0</span>). Le primaire doit Ãªtre une <strong>Ellipse Prolate</strong> pour compenser.</p>
                <div class="formula-box">K1 = -1 + [ (MÂ² - 1) / MÂ³ ] * (Distance Secondaire-Foyer / Focale Primaire)</div>
            </div>
        </div>
    </div>
    <div class="footer-brand">LAVAL SOFTWARE // OPTICAL SUITE v47</div>
</div>

<script>
    // VARS
    var currentData = {};
    var viewState = { scale: 1, offsetX: 0, offsetY: 0, isDragging: false, lastX: 0, lastY: 0 };
    var calculationMode = 'f1';
    var anMode = 'R'; 
    var vizModeAn = '2d';
    var vizModeArch = '2d';
    var scenes = { an: null, arch: null };
    var renderers = { an: null, arch: null };
    var cameras = { an: null, arch: null };
    var controlsList = { an: null, arch: null };
    var meshes = { an: null, arch_m1: null, arch_m2: null, arch_rays: null, arch_struct: null, arch_cam: null, arch_foc: null };

    // --- 2D DRAWING SAFE ---
    function drawBlueprintGeneric(ctx, width, height, type, D, F1, Sep, B, D2, F_sys, holeDiam, theme) {
        D = Math.abs(D)||1; F1=F1||1; Sep=Math.abs(Sep)||0; B=Math.abs(B)||0; D2=Math.abs(D2)||1; holeDiam=Math.abs(holeDiam)||0;
        ctx.clearRect(0,0, width, height); ctx.save();
        if(theme === 'screen') { 
            var dpr = window.devicePixelRatio || 1;
            ctx.translate(viewState.offsetX, viewState.offsetY); 
            ctx.translate(width/2, height/2); 
            ctx.scale(viewState.scale, viewState.scale); 
            ctx.translate(-width/2, -height/2); 
        }
        var C_AXIS="#cccccc"; var C_DIM="#0000ff"; var C_TEXT="#000000"; var C_M1="#ff8800"; var C_M2="#00aa00"; var C_RAY="rgba(0,0,0,0.2)";
        var totalLen = (type==='newton') ? Math.abs(F1)*1.3 : (Math.abs(Sep)+Math.abs(B))*1.2;
        if(totalLen<=0) totalLen=500;
        var scale = (width-120)/totalLen; if(scale<=0) scale=0.1;
        var startX=60; var axisY=height/2;
        ctx.beginPath(); ctx.moveTo(-1000, axisY); ctx.lineTo(width+1000, axisY); ctx.setLineDash([5,5]); ctx.strokeStyle=C_AXIS; ctx.stroke(); ctx.setLineDash([]);
        function dDim(l,x1,x2,y){ctx.beginPath(); ctx.moveTo(x1,y); ctx.lineTo(x2,y); ctx.moveTo(x1,y-5); ctx.lineTo(x1,y+5); ctx.moveTo(x2,y-5); ctx.lineTo(x2,y+5); ctx.strokeStyle=C_DIM; ctx.lineWidth=1/viewState.scale; ctx.stroke(); ctx.fillStyle=C_TEXT; ctx.font=theme==='screen'?"12px Orbitron":"10px Helvetica"; ctx.textAlign="center"; ctx.fillText(l,x1+(x2-x1)/2,y-5);}

        if(type==='newton') {
            var m1X = startX+F1*scale; var m1Rad = (D*scale)/2;
            // Miroir Primaire
            ctx.beginPath(); ctx.arc(m1X-m1Rad*2, axisY, Math.max(0, m1Rad*2), -0.25, 0.25); ctx.strokeStyle=C_M1; ctx.lineWidth=3; ctx.stroke();
            
            // Calcul Position M2 (SÃ©paration Visuelle)
            var tubeR = (D/2)*scale; // Approx tube radius
            // VizSep a Ã©tÃ© passÃ© dans Sep pour le Newton dans le code appelant
            var intercept = (Sep > 0) ? Sep*scale : (F1*scale - tubeR - B*scale);
            var m2X = m1X - intercept;
            
            // Miroir Secondaire (Ligne Ã  45Â°)
            var m2Size = (D2*scale); // Petit axe
            ctx.beginPath(); 
            ctx.moveTo(m2X - m2Size/2, axisY - m2Size/2); 
            ctx.lineTo(m2X + m2Size/2, axisY + m2Size/2);
            ctx.strokeStyle=C_M2; ctx.lineWidth=3; ctx.stroke();

            // Rayons NEWTON CORRIGÃ‰S : CÃ´ne vers M2, puis Focus
            // Le cÃ´ne se rÃ©trÃ©cit de M1 vers le Foyer F1.
            // Il est interceptÃ© par M2.
            // DiamÃ¨tre au niveau de M2 : D2 (environ)
            var m2Rad_ray = (D2*scale)/2; 
            
            ctx.strokeStyle=C_RAY; ctx.beginPath(); 
            // EntrÃ©e -> M1
            ctx.moveTo(startX, axisY - m1Rad); ctx.lineTo(m1X, axisY - m1Rad);
            ctx.moveTo(startX, axisY + m1Rad); ctx.lineTo(m1X, axisY + m1Rad);
            
            // M1 -> M2 (Convergence partielle)
            // Rayon du haut vers bord haut M2
            ctx.moveTo(m1X, axisY - m1Rad); ctx.lineTo(m2X, axisY - m2Rad_ray);
            // Rayon du bas vers bord bas M2
            ctx.moveTo(m1X, axisY + m1Rad); ctx.lineTo(m2X, axisY + m2Rad_ray);
            
            // M2 -> Sortie (Vers le foyer)
            var focH = tubeR + B*scale; // Distance M2 -> Foyer
            // Les rayons se croisent au foyer
            var focusY = axisY - focH;
            
            // Le rayon qui arrive en haut de M2 est rÃ©flÃ©chi vers le foyer
            ctx.moveTo(m2X, axisY - m2Rad_ray); ctx.lineTo(m2X, focusY);
            // Le rayon qui arrive en bas de M2 est rÃ©flÃ©chi vers le foyer
            ctx.moveTo(m2X, axisY + m2Rad_ray); ctx.lineTo(m2X, focusY);
            
            ctx.stroke();

            dDim("F1", m2X, m1X, axisY+m1Rad+30);
            dDim("BACK FOCUS", m2X, m2X, focusY - 10);
            
        } else {
            var m2X=startX; var m1X=startX+Sep*scale; var fX=m1X+B*scale;
            var m1Rad=(D*scale)/2; var m2Rad=(D2*scale)/2; var hRad=(holeDiam*scale)/2;
            var R_draw=m1Rad*4; if(R_draw===0) R_draw=10; var Rcx=m1X-R_draw; 
            var aO=Math.asin(Math.min(1,m1Rad/R_draw)); var aI=Math.asin(Math.min(1,hRad/R_draw));
            ctx.beginPath(); ctx.arc(Rcx, axisY, R_draw, -aO, -aI); ctx.strokeStyle=C_M1; ctx.lineWidth=3; ctx.stroke();
            ctx.beginPath(); ctx.arc(Rcx, axisY, R_draw, aI, aO); ctx.stroke();
            var R2d=m2Rad*4; if(R2d===0) R2d=10; var R2cx=m2X-R2d; var aM2=Math.asin(Math.min(1,m2Rad/R2d));
            ctx.beginPath(); ctx.arc(R2cx, axisY, R2d, -aM2, aM2); ctx.strokeStyle=C_M2; ctx.lineWidth=3; ctx.stroke();
            ctx.strokeStyle=C_RAY; ctx.beginPath(); ctx.moveTo(startX-30,axisY-m1Rad); ctx.lineTo(m1X,axisY-m1Rad); ctx.lineTo(m2X,axisY-m2Rad); ctx.lineTo(fX,axisY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(startX-30,axisY+m1Rad); ctx.lineTo(m1X,axisY+m1Rad); ctx.lineTo(m2X,axisY+m2Rad); ctx.lineTo(fX,axisY); ctx.stroke();
            dDim("SEPARATION",m2X,m1X,axisY-m1Rad-30); dDim("BACK FOCUS",m1X,fX,axisY+m1Rad+30);
            if(holeDiam>0){ var dHx=m1X-30; ctx.beginPath(); ctx.moveTo(dHx,axisY-hRad); ctx.lineTo(dHx,axisY+hRad); ctx.setLineDash([2,2]); ctx.strokeStyle=theme==='screen'?"rgba(255,255,255,0.3)":"#888"; ctx.lineWidth=1; ctx.moveTo(dHx,axisY-hRad); ctx.lineTo(m1X,axisY-hRad); ctx.moveTo(dHx,axisY+hRad); ctx.lineTo(m1X,axisY+hRad); ctx.stroke(); ctx.setLineDash([]); ctx.fillStyle=theme==='screen'?"#ff0055":"#000"; ctx.textAlign="right"; ctx.fillText("Ã˜ "+holeDiam.toFixed(1),dHx-5,axisY+4); }
        }
        ctx.restore();
    }

    // --- GLOBALS ---
    window.redrawCurrentBlueprint = function() {
        if(!currentData.type) return;
        var canvas = document.getElementById('blueprint-canvas');
        if (!canvas) return; 
        var rect = canvas.parentElement.getBoundingClientRect();
        if(rect.width === 0 || rect.height === 0) return;
        var ctx = canvas.getContext('2d');
        var dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr; canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        // On passe VizSep pour le dessin 2D Newton
        drawBlueprintGeneric(ctx, rect.width, rect.height, currentData.type.toLowerCase(), currentData.D, currentData.F1, currentData.VizSep || currentData.Sep, currentData.B, currentData.D2, currentData.F, currentData.Hole, 'screen');
    }

    window.switchTab = function(tabId) {
        document.querySelectorAll('.interface-container').forEach(el => el.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
        document.getElementById(tabId).classList.add('active');
        var btns = document.querySelectorAll('.tab-btn');
        btns.forEach(b => { if(b.getAttribute('onclick').includes(tabId)) b.classList.add('active'); });
        if(tabId === 'architect') setTimeout(window.runArchitect, 100);
    }

    window.setAnMode = function(mode) {
        if(mode === anMode) return;
        var input = document.getElementById('an-curvature-val');
        var val = parseFloat(input.value);
        if(mode === 'F') { input.value = (val / 2).toFixed(2); document.getElementById('mode-an-R').classList.remove('active'); document.getElementById('mode-an-F').classList.add('active'); } 
        else { input.value = (val * 2).toFixed(2); document.getElementById('mode-an-F').classList.remove('active'); document.getElementById('mode-an-R').classList.add('active'); }
        anMode = mode; window.runAnalyzer();
    }

    window.setVizMode = function(ctx, mode) {
        if(ctx === 'an') {
            vizModeAn = mode;
            document.getElementById('tab-an-2d').classList.toggle('active', mode==='2d');
            document.getElementById('tab-an-3d').classList.toggle('active', mode==='3d');
            document.getElementById('visualizer').style.display = mode==='2d'?'block':'none';
            document.getElementById('container3d_an').style.display = mode==='3d'?'block':'none';
            document.getElementById('cam-an').style.display = mode==='3d'?'flex':'none';
            if(mode==='2d') window.runAnalyzer(); else updateAn3D();
        } else {
            vizModeArch = mode;
            document.getElementById('tab-arch-2d').classList.toggle('active', mode==='2d');
            document.getElementById('tab-arch-3d').classList.toggle('active', mode==='3d');
            document.getElementById('blueprint-canvas').style.display = mode==='2d'?'block':'none';
            document.getElementById('zoom-controls-2d').style.display = mode==='2d'?'flex':'none';
            document.getElementById('container3d_arch').style.display = mode==='3d'?'block':'none';
            document.getElementById('cam-arch').style.display = mode==='3d'?'flex':'none';
            if(mode==='2d') window.redrawCurrentBlueprint(); else updateArch3D();
        }
    }

    window.resetCamera = function(ctx, view) {
        if(!cameras[ctx] || !controlsList[ctx]) return;
        var cam = cameras[ctx]; var ctr = controlsList[ctx];
        ctr.reset();
        if (ctx === 'an') {
            if(view === 'front') { cam.position.set(0, 500, 0); } 
            else if(view === 'back') { cam.position.set(0, -500, 0); } 
            else if(view === 'side') { cam.position.set(0, 50, 500); } 
            else { cam.position.set(0, 300, 500); } 
        } else {
            if(view === 'front') { cam.position.set(0, 0, 1500); } 
            else if(view === 'side') { cam.position.set(1500, 0, -500); } 
            else { cam.position.set(800, 500, 1000); } 
        }
        cam.lookAt(0,0,0);
        ctr.update();
    }

    // Fonction de 3D pour l'Analyseur (DÃ©claration explicite pour hoisting)
    function updateAn3D() {
        if(!scenes.an) init3D('an'); var sc = scenes.an; if(meshes.an) sc.remove(meshes.an);
        
        var D = parseFloat(document.getElementById('an-diameter').value) || 0; 
        var thick = parseFloat(document.getElementById('an-thickness').value) || 0; 
        var holeD = parseFloat(document.getElementById('an-hole').value) || 0;
        var R_val = parseFloat(document.getElementById('an-curvature-val').value) || 0; 
        
        if (D <= 0 || R_val === 0) return; // Stop if invalid dimensions

        var R = (anMode === 'F') ? R_val * 2 : R_val;
        
        var points = []; var segments = 40; var radius = D/2; var holeR = holeD/2;
        
        // Sagitta at edge
        var sagEdge = (radius*radius)/(2*R);

        // Back is flat at y=0
        points.push(new THREE.Vector2(holeR, 0)); 
        points.push(new THREE.Vector2(radius, 0)); 
        points.push(new THREE.Vector2(radius, thick));
        
        // Front surface (Concave)
        for(let i=0; i<=segments; i++) { 
            let r = radius - (i/segments)*(radius-holeR); 
            // Sagitta at r
            let sagLocal = (r*r)/(2*R);
            // y position relative to edge
            let y = thick - (sagEdge - sagLocal);
            points.push(new THREE.Vector2(r, y)); 
        }
        points.push(new THREE.Vector2(holeR, 0)); // Close loop

        var geo = new THREE.LatheGeometry(points, 64); geo.computeVertexNormals();
        var mat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness:0.9, roughness:0.1, clearcoat: 1.0, clearcoatRoughness: 0.1, side:THREE.DoubleSide });
        meshes.an = new THREE.Mesh(geo, mat); sc.add(meshes.an);
    }

    window.runAnalyzer = function() {
        var D = parseFloat(document.getElementById('an-diameter').value)||0; var holeD = parseFloat(document.getElementById('an-hole').value)||0; var thick = parseFloat(document.getElementById('an-thickness').value)||0;
        var R_val = parseFloat(document.getElementById('an-curvature-val').value)||0;
        var R = (anMode === 'F') ? R_val * 2 : R_val;
        var K = parseFloat(document.getElementById('an-kfactor').value);
        var zonesStr = document.getElementById('an-zones').value;
        var zones = zonesStr.split(',').map(Number).filter(n=>n);
        var tbody = document.getElementById('an-results'); tbody.innerHTML="";
        
        var r_cm=(D/2)/10; var h_cm=thick/10; var rh_cm=(holeD/2)/10; var zmax_cm=(R>0)?((D/2)*(D/2)/(2*R))/10 : 0;
        var vol = (Math.PI*r_cm*r_cm*h_cm) - (Math.PI*rh_cm*rh_cm*h_cm) - (0.5*Math.PI*r_cm*r_cm*zmax_cm);
        document.getElementById('an-weight').innerText = (vol*2.53/1000).toFixed(2)+" kg";

        if (vizModeAn === '2d') {
            var cvs = document.getElementById('visualizer'); 
            var dpr = window.devicePixelRatio || 1;
            var rect = cvs.parentElement.getBoundingClientRect();
            
            if (rect.width === 0 || rect.height === 0) return;

            cvs.width = rect.width * dpr; cvs.height = rect.height * dpr;
            var ctx = cvs.getContext('2d'); ctx.scale(dpr, dpr);
            ctx.clearRect(0,0,rect.width,rect.height); ctx.fillStyle="#ffffff"; ctx.fillRect(0,0,rect.width,rect.height); 
            
            var W = rect.width; var H = rect.height; var midX = W/2;
            var pad = 20; 
            var maxR_face = Math.max(0, Math.min(midX, H)/2 - pad);
            var scFace = (D>0) ? maxR_face/(D/2) : 1; var cxF = midX/2; var cyF = H/2;
            
            // 1. Vue de Face
            ctx.beginPath(); ctx.arc(cxF, cyF, Math.max(0, (D/2)*scFace), 0, Math.PI*2);
            ctx.fillStyle="#f0f0f0"; ctx.fill(); ctx.strokeStyle="#333"; ctx.lineWidth=2; ctx.stroke();
            if(holeD>0) { ctx.beginPath(); ctx.arc(cxF, cyF, Math.max(0, (holeD/2)*scFace), 0, Math.PI*2); ctx.fillStyle="#fff"; ctx.fill(); ctx.strokeStyle="#333"; ctx.lineWidth=1; ctx.stroke(); }
            zones.forEach(z=>{
                ctx.beginPath(); ctx.arc(cxF, cyF, Math.max(0, z*scFace), 0, Math.PI*2);
                ctx.strokeStyle="#0000ff"; ctx.lineWidth=1; ctx.stroke();
            });
            ctx.fillStyle="#000"; ctx.font="12px Orbitron"; ctx.textAlign="center"; ctx.fillText("VUE DE FACE", cxF, H - 10);

            // 2. Vue de Coupe CORRIGÃ‰E SENS HORAIRE
            var cxC = midX + midX/2; var cyC = H/2; var scCoupe = scFace * 0.8; 
            ctx.beginPath(); ctx.moveTo(cxC-maxR_face, cyC); ctx.lineTo(cxC+maxR_face, cyC); ctx.setLineDash([5,5]); ctx.strokeStyle="#ccc"; ctx.stroke(); ctx.setLineDash([]);
            var rad = D/2; var hRad = holeD/2;
            
            // Partie Droite (Contour FermÃ©)
            ctx.beginPath();
            var z_edge = (rad*rad)/(2*R);
            // 1. Haut-Ext
            ctx.moveTo(cxC + rad*scCoupe, cyC - z_edge*scCoupe); // removed *50
            // 2. Courbe vers Haut-Int
            for(let x=rad; x>=hRad; x-=1) {
                let z = (x*x)/(2*R);
                ctx.lineTo(cxC + x*scCoupe, cyC - z*scCoupe); // removed *50
            }
            // 3. Bas-Int
            ctx.lineTo(cxC + hRad*scCoupe, cyC + thick*scCoupe);
            // 4. Bas-Ext
            ctx.lineTo(cxC + rad*scCoupe, cyC + thick*scCoupe);
            // 5. Fermeture
            ctx.closePath();
            ctx.fillStyle="#ddd"; ctx.fill(); ctx.strokeStyle="#000"; ctx.stroke();

            // Partie Gauche
            ctx.beginPath();
            ctx.moveTo(cxC - rad*scCoupe, cyC - z_edge*scCoupe);
            for(let x=rad; x>=hRad; x-=1) {
                let z = (x*x)/(2*R);
                ctx.lineTo(cxC - x*scCoupe, cyC - z*scCoupe);
            }
            ctx.lineTo(cxC - hRad*scCoupe, cyC + thick*scCoupe);
            ctx.lineTo(cxC - rad*scCoupe, cyC + thick*scCoupe);
            ctx.closePath();
            ctx.fillStyle="#ddd"; ctx.fill(); ctx.strokeStyle="#000"; ctx.stroke();

            // Chanfreins
            ctx.fillStyle="#999";
            // Droit
            ctx.beginPath(); ctx.moveTo(cxC+rad*scCoupe, cyC - z_edge*scCoupe); ctx.lineTo(cxC+rad*scCoupe-5, cyC - z_edge*scCoupe + 5); ctx.lineTo(cxC+rad*scCoupe, cyC - z_edge*scCoupe + 10); ctx.fill();
            // Gauche
            ctx.beginPath(); ctx.moveTo(cxC-rad*scCoupe, cyC - z_edge*scCoupe); ctx.lineTo(cxC-rad*scCoupe+5, cyC - z_edge*scCoupe + 5); ctx.lineTo(cxC-rad*scCoupe, cyC - z_edge*scCoupe + 10); ctx.fill();
            
            ctx.fillStyle="#000"; ctx.fillText("PROFIL (Z x1)", cxC, H - 10);

        } else { updateAn3D(); }

        var c = (R>0)?1/R:0;
        zones.forEach((S,i)=>{
            var term = 1-(K+1)*Math.pow(c*S,2);
            var err = ""; if(S>D/2) err="HORS MIROIR"; else if(S<holeD/2) err="DANS TROU"; else if(term<0) err="ERR GEOM";
            if(err) tbody.innerHTML+=`<tr><td>${i+1}</td><td>${S}</td><td colspan="3" style="color:red">${err}</td></tr>`;
            else {
                var z = (c*S*S)/(1+Math.sqrt(term));
                var A = c*z*(K+1); var Y = -K*z*(3+A*(A-3)); var X = (-2*S*c*K*z*(2+A*(A-3)))/(1-A);
                tbody.innerHTML+=`<tr><td style="color:#00f3ff">Z${i+1}</td><td>${S}</td><td>${z.toFixed(3)}</td><td>${Y.toFixed(3)}</td><td style="color:#00f3ff; font-weight:bold">${X.toFixed(3)}</td></tr>`;
            }
        });
    }

    window.updateAnalyzerK = function() {
        var type = document.getElementById('an-type').value;
        var kInput = document.getElementById('an-kfactor');
        if(type === 'custom') { kInput.disabled = false; kInput.style.backgroundColor = 'rgba(255,255,255,0.15)'; } 
        else { kInput.disabled = true; kInput.style.backgroundColor = 'rgba(255,255,255,0.05)';
            if(type === 'parabola') kInput.value = -1; else if(type === 'sphere') kInput.value = 0;
            else if(type === 'hyperbola') kInput.value = -1.1; else if(type === 'ellipse') kInput.value = -0.5; }
    }
    
    window.setCalcMode = function(mode) {
        calculationMode = mode;
        var f1=document.getElementById('arch-F1'); 
        var sep=document.getElementById('arch-Sep');
        var fSys=document.getElementById('arch-F');

        // Reset classes
        document.getElementById('mode-f1').classList.remove('active');
        document.getElementById('mode-sep').classList.remove('active');
        document.getElementById('mode-auto').classList.remove('active');
        document.getElementById('mode-free').classList.remove('active');

        // Logic
        if(mode==='f1'){
            f1.disabled=false; sep.disabled=true; fSys.disabled=false;
            document.getElementById('lock-f1').style.display='inline';
            document.getElementById('lock-sep').style.display='none';
            document.getElementById('mode-f1').classList.add('active');
            fSys.style.opacity = '1';
        }
        else if(mode==='sep'){
            f1.disabled=true; sep.disabled=false; fSys.disabled=false;
            document.getElementById('lock-f1').style.display='none';
            document.getElementById('lock-sep').style.display='inline';
            document.getElementById('mode-sep').classList.add('active');
            fSys.style.opacity = '1';
        }
        else if(mode==='auto'){
            // Mode Auto: F1 et Sep sont calculÃ©s, F est input
            f1.disabled=true; sep.disabled=true; fSys.disabled=false;
            document.getElementById('lock-f1').style.display='none';
            document.getElementById('lock-sep').style.display='none';
            document.getElementById('mode-auto').classList.add('active');
            fSys.style.opacity = '1';
        }
        else if(mode==='free'){
            f1.disabled=false; sep.disabled=false; 
            // Focale SystÃ¨me devient une rÃ©sultante
            fSys.disabled=true; 
            fSys.style.opacity = '0.5';
            document.getElementById('lock-f1').style.display='none';
            document.getElementById('lock-sep').style.display='none';
            document.getElementById('mode-free').classList.add('active');
        }
    }

    window.updateArchUI = function() {
        var type = document.getElementById('arch-type').value;
        if(type === 'newton') { 
            document.getElementById('calc-mode-container').style.opacity='0.3'; 
            document.getElementById('calc-mode-container').style.pointerEvents='none'; 
            window.setCalcMode('f1'); 
            document.getElementById('sec-card').style.opacity='0.3'; 
        } 
        else { 
            document.getElementById('calc-mode-container').style.opacity='1'; 
            document.getElementById('calc-mode-container').style.pointerEvents='all'; 
            document.getElementById('sec-card').style.opacity='1'; 
        }
        window.runArchitect();
    }

    window.runArchitect = function() {
        var type = document.getElementById('arch-type').value;
        var D = parseFloat(document.getElementById('arch-D').value) || 0;
        var B = parseFloat(document.getElementById('arch-B').value) || 0;
        
        var F=0, F1=0, Sep=0, M=0;
        var VizSep = 0; 
        
        // Variables pour les rÃ©sultats, initialisÃ©es ici pour Ã©viter les problÃ¨mes de portÃ©e (scoping)
        var R1=0, K1=0, R2=0, K2=0, s1="-", s2="-", D2_val=0, hD=0;

        if(type === 'newton') {
            // Newton: On force F = F1. On lit F1 car le mode par dÃ©faut est 'FIXER F1'.
            // Si on est en mode 'Focale SystÃ¨me', on force F1 = F.
            // Simplification : Dans Newton, F = F1.
            var inputF = parseFloat(document.getElementById('arch-F').value) || 0;
            var inputF1 = parseFloat(document.getElementById('arch-F1').value) || 0;
            
            // DÃ©tection de changement pour Newton : Prioriser l'utilisateur s'il change F ou F1
            // Si c'est le premier run ou switch de type, on garde F.
            if(currentData.type === 'NEWTON') {
                if (inputF !== currentData.F) {
                    F = inputF;
                } else if (inputF1 !== currentData.F1) {
                    F = inputF1;
                } else {
                    F = inputF;
                }
            } else {
                F = inputF;
            }
            
            F1 = F;
            
            // Update UI fields
            document.getElementById('arch-F').value = F.toFixed(2);
            document.getElementById('arch-F1').value = F1.toFixed(2); // Sync

            Sep = 0; M = 1; 
            
            // Calculer D2 (Petit Axe) pour avoir le champ pleine lumiÃ¨re minimal au foyer
            // Distance du primaire au foyer = F
            // Distance du primaire au secondaire = F - (D/2 + B)
            // Distance du foyer au secondaire = D/2 + B
            // Thales: d / D = (D/2 + B) / F
            if (F > 0) {
                // Petit axe gÃ©omÃ©trique minimum pour illuminer le centre
                // Pour du champ pleine lumiÃ¨re, il faudrait ajouter (Champ * (F-Dist)/F).
                // Ici on fait le minimum gÃ©omÃ©trique (obstruction minimale).
                D2_val = (D * ((D/2) + B)) / F;
            } else {
                D2_val = 0;
            }
            if(D2_val<=0) D2_val=10; // Fallback

            VizSep = Math.max(0, F - (D/2 + B));
        } 
        else {
            // Logique de calcul selon le mode
            if(calculationMode === 'free') {
                F1 = parseFloat(document.getElementById('arch-F1').value)||0;
                Sep = parseFloat(document.getElementById('arch-Sep').value)||0;
                VizSep = Sep;
                
                if(F1 > 0 && Sep >= F1) {
                    alert("ERREUR GÃ‰OMÃ‰TRIQUE : La sÃ©paration ne peut pas Ãªtre plus grande que la focale primaire (F1).");
                    return;
                }
                
                if(F1 - Sep !== 0) {
                    M = (Sep + B) / (F1 - Sep);
                } else {
                    M = 0; 
                }
                F = F1 * M;
                document.getElementById('arch-F').value = F.toFixed(2);
            }
            else {
                F = parseFloat(document.getElementById('arch-F').value) || 0;
                
                if(calculationMode === 'auto') {
                    F1 = D * 3.5;
                    document.getElementById('arch-F1').value = F1.toFixed(2);
                    M = (F1 > 0) ? F / F1 : 0;
                    Sep = (M * F1 - B) / (M + 1);
                    document.getElementById('arch-Sep').value = Sep.toFixed(2);
                }
                else if(calculationMode === 'f1') { 
                    F1 = parseFloat(document.getElementById('arch-F1').value)||0; 
                    M = (F1>0) ? F/F1 : 0; 
                    Sep = (M*F1 - B)/(M+1); 
                    document.getElementById('arch-Sep').value = Sep.toFixed(2); 
                } 
                else { 
                    Sep = parseFloat(document.getElementById('arch-Sep').value)||0; 
                    M = (Sep>0) ? (F-B-Sep)/Sep : 0; 
                    if(M<=0){ return; } 
                    F1 = F/M; 
                    document.getElementById('arch-F1').value = F1.toFixed(2); 
                }
                VizSep = Sep;
            }
        }

        R1=2*F1; 
        
        if(type==='newton') { 
            K1=-1; R2=0; K2=0; s1="Parabole"; s2="Plan"; 
            hD=0; 
        } 
        else if(F1 > 0) {
            if(M === 1) { R2 = 0; } else { R2 = (2*Sep*M)/(M-1); }
            D2_val = (D*(F1-Sep))/F1; 
            hD = D2_val*(B/(Sep+B));

            if(type==='cassegrain') { K1=-1; s1="Parabole"; var t=(M+1)/(M-1); K2=-(t*t); s2="Hyperbole"; } 
            else if(type==='dk') { K2=0; s2="SphÃ¨re"; var p=Sep+B; var t=(Math.pow(M,2)-1)/Math.pow(M,3); K1=-1+t*(p/F1); s1="Ellipse Prolate"; }
            else if(type==='rc') { K1=-1-(2*B)/(Math.pow(M,3)*Sep); K2=-Math.pow((M+1)/(M-1),2)-(4*M*(M+1))/((M-1)*Math.pow(M,2))*(B/Sep); s1="Hyperbole"; s2="Hyperbole"; }
            else { K1=0; K2=0; s1="SphÃ¨re"; s2="SphÃ¨re"; }
        }

        var D_obs = Math.abs(D2_val); 
        var Deff = Math.sqrt(Math.max(0, Math.pow(D, 2) - Math.pow(D_obs, 2))).toFixed(1);

        currentData = { type: type.toUpperCase(), D: D, F: F, F1: F1, B: B, Sep: Sep, VizSep: VizSep, M: M, R1: R1, K1: K1, Shape1: s1, Hole: hD, R2: Math.abs(R2), K2: K2, Shape2: s2, D2: Math.abs(D2_val), Deff: Deff };

        document.getElementById('res-fd').innerText = (D>0 && F>0) ? "f/" + (F/D).toFixed(1) : "-";
        document.getElementById('res-mag').innerText = isFinite(M) ? M.toFixed(2) + "x" : "Err";
        document.getElementById('res-obst').innerText = (D>0) ? (Math.abs(D2_val)/D*100).toFixed(1) + "%" : "-";
        document.getElementById('res-d-eff').innerText = Deff + " mm";
        var resArc = (D>0) ? (116/D).toFixed(2) + '"' : "-";
        document.getElementById('res-resol').innerText = resArc;

        document.getElementById('res-r1').innerText = R1.toFixed(2);
        document.getElementById('res-f1-out').innerText = F1.toFixed(2);
        document.getElementById('res-k1').innerText = K1.toFixed(4);
        document.getElementById('res-shape1').innerText = s1;
        document.getElementById('res-hole').innerText = hD>0 ? hD.toFixed(1)+" mm" : "N/A";
        
        // --- Added: Display Shape2 ---
        document.getElementById('res-shape2').innerText = s2;

        if(type !== 'newton') {
            document.getElementById('res-r2').innerText = isFinite(R2) ? Math.abs(R2).toFixed(2) : "-";
            document.getElementById('res-sep-out').innerText = Sep.toFixed(2);
            document.getElementById('res-k2').innerText = isFinite(K2) ? K2.toFixed(4) : "-";
            document.getElementById('res-d2').innerText = Math.abs(D2_val).toFixed(1);
        } else {
            document.getElementById('res-r2').innerText = "-";
            document.getElementById('res-sep-out').innerText = "-";
            document.getElementById('res-k2').innerText = "-";
            document.getElementById('res-d2').innerText = Math.abs(D2_val).toFixed(1);
        }
        if(vizModeArch === '2d') window.redrawCurrentBlueprint(); else updateArch3D();
    }

    window.zoomBlueprint = function(delta) { 
        viewState.scale += delta; if(viewState.scale < 0.1) viewState.scale = 0.1; if(viewState.scale > 5) viewState.scale = 5; 
        window.redrawCurrentBlueprint(); 
    }
    window.resetZoom = function() { viewState.scale = 1; viewState.offsetX = 0; viewState.offsetY = 0; window.redrawCurrentBlueprint(); }
    
    window.downloadPDF = function() {
        var { jsPDF } = window.jspdf;
        var doc = new jsPDF();
        var pName = document.getElementById('project-name').value || "Projet Optique";
        doc.setFontSize(22); doc.text("LAVAL SOFTWARE // RAPPORT", 20, 20);
        doc.setFontSize(16); doc.setTextColor(0, 86, 179); doc.text(pName, 20, 30);
        doc.setFontSize(10); doc.setTextColor(0,0,0); doc.text("Date: "+new Date().toLocaleDateString(), 150, 20);

        var cvs = document.createElement('canvas'); cvs.width=2000; cvs.height=1000;
        var ctx = cvs.getContext('2d'); ctx.fillStyle="#fff"; ctx.fillRect(0,0,2000,1000);
        
        var oldState = {...viewState}; viewState={scale:1, offsetX:0, offsetY:0};
        drawBlueprintGeneric(ctx, 2000, 1000, currentData.type.toLowerCase(), currentData.D, currentData.F1, currentData.VizSep || currentData.Sep, currentData.B, currentData.D2, currentData.F, currentData.Hole, 'print');
        viewState = oldState;

        doc.addImage(cvs.toDataURL("image/png"), 'PNG', 10, 40, 190, 95);
        var y=150; doc.line(10,y,200,y); doc.setFontSize(12); doc.setFont("helvetica","bold"); doc.text("DONNÃ‰ES", 10, y-5);
        doc.setFontSize(10); doc.setFont("helvetica","normal");
        doc.text(`DiamÃ¨tre: ${currentData.D} mm`, 15, y+10);
        doc.text(`DiamÃ¨tre Pur: ${currentData.Deff} mm`, 15, y+20);
        doc.text(`Focale: ${currentData.F} mm (f/${(currentData.F/currentData.D).toFixed(1)})`, 15, y+30);
        doc.text(`PRIMAIRE (R1): ${currentData.R1.toFixed(2)} mm (K=${currentData.K1.toFixed(4)})`, 80, y+10);
        if(currentData.type!=='NEWTON'){
            doc.text(`SECONDAIRE (R2): ${currentData.R2.toFixed(2)} mm (K=${currentData.K2.toFixed(4)})`, 80, y+20);
            doc.text(`SÃ©paration: ${currentData.Sep.toFixed(2)} mm`, 80, y+30);
        }
        doc.save("Rapport.pdf");
    }

    window.downloadCoursePDF = function() {
        var { jsPDF } = window.jspdf;
        var doc = new jsPDF();
        var addWrappedText = (text, x, y, maxWidth, lineHeight) => {
            var lines = doc.splitTextToSize(text, maxWidth);
            doc.text(lines, x, y);
            return lines.length * lineHeight;
        };
        doc.setFontSize(22); doc.setTextColor(0,0,0);
        doc.text("LAVAL SOFTWARE // COURS OPTIQUE", 20, 20);
        doc.setFontSize(16); doc.setTextColor(0, 86, 179);
        doc.text("THÃ‰ORIE DE LA CAUSTIQUE & ARCHITECTURE", 20, 35);
        doc.setFontSize(12); doc.setTextColor(100, 100, 100);
        doc.text("Auteur : Ludovic Laval", 20, 45);
        doc.setFontSize(11); doc.setTextColor(0,0,0);
        var y = 60;
        y += addWrappedText("1. LE TEST DE LA CAUSTIQUE (PLATZECK-GAVIOLA)\n\nLes miroirs paraboliques ou hyperboliques ne focalisent pas la lumiÃ¨re en un point unique lorsqu'on les teste depuis leur centre de courbure (contrairement Ã  une sphÃ¨re). Chaque zone du miroir a un point de convergence diffÃ©rent (la caustique). Ce logiciel calcule les coordonnÃ©es (X, Y) pour le test de Foucault.", 20, y, 170, 7);
        y += 10;
        doc.setFont("helvetica", "bold"); doc.text("2. FORMULES (Cornejo & Malacara)", 20, y); y+=10;
        doc.setFont("courier", "normal"); 
        doc.text("c = 1 / R", 25, y); y+=7;
        doc.text("z = (c * S^2) / (1 + sqrt(1 - (K+1)*c^2*S^2))", 25, y); y+=7;
        doc.text("Y = -K*z * [3 + c*z*(K+1)*(c*z*(K+1)-3)]", 25, y); y+=7;
        doc.text("X = -2*S*c*K*z * [2 + ... ] / (1 - ...)", 25, y); y+=15;
        doc.setFont("helvetica", "bold"); doc.text("3. ARCHITECTURE (Schwarzschild)", 20, y); y+=10;
        doc.setFont("helvetica", "normal");
        y += addWrappedText("Le module Architecte utilise les Ã©quations du 3Ã¨me ordre pour Ã©liminer l'aberration sphÃ©rique et la coma. Pour un Dall-Kirkham, le primaire est une ellipse prolate compensant un secondaire sphÃ©rique.", 20, y, 170, 7);
        doc.save("Cours_Optique_LavalSoftware.pdf");
    }

    window.autoCalcZones = function() {
        var D = parseFloat(document.getElementById('an-diameter').value)||0; var holeD = parseFloat(document.getElementById('an-hole').value)||0;
        var R_val = parseFloat(document.getElementById('an-curvature-val').value)||0;
        var R = (anMode === 'F') ? R_val * 2 : R_val;
        var forcedN = parseInt(document.getElementById('an-nb-zones').value);
        if(!D || !R) return;
        var width_mm = 4.53 * Math.pow(((R/2)/D) * Math.pow(R/10, 2), 1/3) * 0.1;
        var radiusMirror = D / 2; var numZones = forcedN > 0 ? forcedN : Math.ceil(radiusMirror / width_mm);
        if(forcedN <=0) document.getElementById('an-nb-zones').value = numZones; 
        var actualWidth = radiusMirror / numZones;
        var zoneCenters = [];
        for(let i=0; i<numZones; i++) {
            var center = (i * actualWidth) + (actualWidth/2);
            if(center > (holeD/2 + 2)) zoneCenters.push(center.toFixed(1));
        }
        document.getElementById('an-zones').value = zoneCenters.join(', ');
        document.getElementById('an-maxw').innerText = width_mm.toFixed(1) + " mm";
        window.runAnalyzer();
    }

    // --- 3D ENGINE ---
    function init3D(type) {
        var container = document.getElementById(type === 'an' ? 'container3d_an' : 'container3d_arch');
        var w = container.offsetWidth; var h = container.offsetHeight;
        var sc = new THREE.Scene(); sc.background = new THREE.Color(0xffffff); 
        var cam = new THREE.PerspectiveCamera(45, w/h, 1, 10000); 
        if(type==='an') cam.position.set(0, 300, 500); else cam.position.set(500, 500, 1000);
        var ren = new THREE.WebGLRenderer({ antialias: true }); ren.setSize(w, h);
        ren.setPixelRatio(window.devicePixelRatio); // HD
        container.innerHTML = ""; container.appendChild(ren.domElement);
        var ctr = new THREE.OrbitControls(cam, ren.domElement); ctr.enableDamping=true; 
        
        sc.add(new THREE.AmbientLight(0xffffff, 0.6));
        var dl = new THREE.DirectionalLight(0xffffff, 1.0); dl.position.set(500,1000,500); sc.add(dl);
        var pl = new THREE.PointLight(0xccccff, 0.5); pl.position.set(-200, 200, 200); sc.add(pl);

        scenes[type] = sc; cameras[type] = cam; renderers[type] = ren; controlsList[type] = ctr;
        var animate = function() { requestAnimationFrame(animate); ctr.update(); ren.render(sc, cam); };
        animate();
    }

    function updateAn3D() {
        if(!scenes.an) init3D('an'); var sc = scenes.an; if(meshes.an) sc.remove(meshes.an);
        
        var D = parseFloat(document.getElementById('an-diameter').value) || 0; 
        var thick = parseFloat(document.getElementById('an-thickness').value) || 0; 
        var holeD = parseFloat(document.getElementById('an-hole').value) || 0;
        var R_val = parseFloat(document.getElementById('an-curvature-val').value) || 0; 
        
        if (D <= 0 || R_val === 0) return; // Stop if invalid dimensions

        var R = (anMode === 'F') ? R_val * 2 : R_val;
        
        var points = []; var segments = 40; var radius = D/2; var holeR = holeD/2;
        
        // Sagitta at edge
        var sagEdge = (radius*radius)/(2*R);

        // Back is flat at y=0
        points.push(new THREE.Vector2(holeR, 0)); 
        points.push(new THREE.Vector2(radius, 0)); 
        points.push(new THREE.Vector2(radius, thick));
        
        // Front surface (Concave)
        for(let i=0; i<=segments; i++) { 
            let r = radius - (i/segments)*(radius-holeR); 
            // Sagitta at r
            let sagLocal = (r*r)/(2*R);
            // y position relative to edge
            let y = thick - (sagEdge - sagLocal);
            points.push(new THREE.Vector2(r, y)); 
        }
        points.push(new THREE.Vector2(holeR, 0)); // Close loop

        var geo = new THREE.LatheGeometry(points, 64); geo.computeVertexNormals();
        var mat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness:0.9, roughness:0.1, clearcoat: 1.0, clearcoatRoughness: 0.1, side:THREE.DoubleSide });
        meshes.an = new THREE.Mesh(geo, mat); sc.add(meshes.an);
    }

    function updateArch3D() {
        if(!scenes.arch) init3D('arch'); var sc = scenes.arch;
        if(meshes.arch_m1) sc.remove(meshes.arch_m1); if(meshes.arch_m2) sc.remove(meshes.arch_m2); if(meshes.arch_rays) sc.remove(meshes.arch_rays); if(meshes.arch_struct) sc.remove(meshes.arch_struct);
        if(meshes.arch_cam) sc.remove(meshes.arch_cam);
        if(meshes.arch_foc) sc.remove(meshes.arch_foc); // NEW: Clean up focuser mesh

        if(!currentData.type) return;

        // Visual Clamping
        var visualSep = currentData.VizSep || currentData.Sep;
        if (visualSep > currentData.F1) visualSep = currentData.F1 * 0.95;

        // MIROIR PRIMAIRE
        var R1 = currentData.D/2; var H1 = currentData.Hole/2; var thick1 = currentData.D/6;
        var pts1 = [];
        pts1.push(new THREE.Vector2(H1, 0)); pts1.push(new THREE.Vector2(R1, 0)); pts1.push(new THREE.Vector2(R1, thick1)); 
        for(let i=0; i<=40; i++){ 
            let r = R1 - (i/40)*(R1-H1); 
            let sag = (r*r)/(4*currentData.F1); 
            pts1.push(new THREE.Vector2(r, thick1 - ( (R1*R1)/(4*currentData.F1) - sag )));
        }
        pts1.push(new THREE.Vector2(H1, 0)); 
        var m1 = new THREE.Mesh(new THREE.LatheGeometry(pts1, 64), new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness:0.9, roughness:0.1, side:THREE.DoubleSide }));
        m1.rotation.x = Math.PI/2; sc.add(m1); meshes.arch_m1 = m1;

        if(currentData.type !== 'NEWTON') {
            // ... (CODE EXISTANT POUR CASSEGRAIN/RC/DK) ...
            var R2 = currentData.D2/2; var Sep = visualSep; var thick2 = R2/3;
            var pts2 = [];
            pts2.push(new THREE.Vector2(0, 0)); pts2.push(new THREE.Vector2(R2, 0)); pts2.push(new THREE.Vector2(R2, thick2)); 
            for(let i=0; i<=20; i++){ 
                let r = R2 - (i/20)*R2; let sag = (r*r)/(1000); 
                pts2.push(new THREE.Vector2(r, thick2 + sag)); 
            }
            var m2 = new THREE.Mesh(new THREE.LatheGeometry(pts2, 64), new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness:0.9, roughness:0.1, side:THREE.DoubleSide }));
            m2.rotation.x = -Math.PI/2; m2.position.z = Sep; sc.add(m2); meshes.arch_m2 = m2;

            // RAYONS
            var numRays = 16; var ptsAll = [];
            var Z_start = Sep + 500; var Z_m1 = thick1; var Z_m2 = Sep - thick2; var Z_foc = -currentData.B;
            for(let i=0; i<numRays; i++) {
                var angle = (i/numRays) * Math.PI * 2;
                var x = Math.cos(angle) * R1; var y = Math.sin(angle) * R1;
                var x2 = Math.cos(angle) * (currentData.D2/2); var y2 = Math.sin(angle) * (currentData.D2/2);
                ptsAll.push(new THREE.Vector3(x, y, Z_start)); ptsAll.push(new THREE.Vector3(x, y, Z_m1));
                ptsAll.push(new THREE.Vector3(x, y, Z_m1)); ptsAll.push(new THREE.Vector3(x2, y2, Z_m2));
                ptsAll.push(new THREE.Vector3(x2, y2, Z_m2)); ptsAll.push(new THREE.Vector3(0, 0, Z_foc));
            }
            var lRays = new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(ptsAll), new THREE.LineBasicMaterial({ color: 0xaa00ff, opacity: 0.6, transparent: true }));
            sc.add(lRays); meshes.arch_rays = lRays;
            
            // CAMERA
            var camRad = 35; var camLen = 40; 
            var camGeo = new THREE.CylinderGeometry(camRad, camRad, camLen, 32);
            var camMat = new THREE.MeshStandardMaterial({color: 0xcc0000, metalness:0.6, roughness:0.2});
            var cam = new THREE.Mesh(camGeo, camMat);
            cam.rotation.x = Math.PI/2;
            cam.position.z = Z_foc - (camLen/2);
            sc.add(cam); meshes.arch_cam = cam;

            // STRUCTURE
            var trussGroup = new THREE.Group(); 
            var boxR = R1*1.2; 
            var matTruss = new THREE.MeshStandardMaterial({color: 0x222222, roughness:0.9});
            for(let i=0; i<8; i++) {
                var a1 = (Math.floor(i/2)*90)*(Math.PI/180); var a2 = (i%2===1 ? a1+Math.PI/4 : a1-Math.PI/4);
                var v1 = new THREE.Vector3(Math.cos(a1)*boxR, Math.sin(a1)*boxR, 0);
                var v2 = new THREE.Vector3(Math.cos(a2)*boxR, Math.sin(a2)*boxR, Sep);
                var dist = v1.distanceTo(v2);
                var tube = new THREE.Mesh(new THREE.CylinderGeometry(5,5,dist,8), matTruss);
                tube.position.copy(new THREE.Vector3().addVectors(v1,v2).multiplyScalar(0.5));
                tube.lookAt(v2); tube.rotateX(Math.PI/2); trussGroup.add(tube);
            }
            var spiderMat = new THREE.MeshBasicMaterial({color: 0x111111});
            var spiderV = new THREE.Mesh(new THREE.BoxGeometry(4, boxR*2, 20), spiderMat); spiderV.position.z = Sep + 20; trussGroup.add(spiderV);
            var spiderH = new THREE.Mesh(new THREE.BoxGeometry(boxR*2, 4, 20), spiderMat); spiderH.position.z = Sep + 20; trussGroup.add(spiderH);
            var cell = new THREE.Mesh(new THREE.CylinderGeometry(boxR,boxR,20,32), new THREE.MeshStandardMaterial({color:0x111111})); cell.rotation.x = Math.PI/2; cell.position.z = -10; trussGroup.add(cell);
            var cage = new THREE.Mesh(new THREE.TorusGeometry(boxR,5,16,100), matTruss); cage.position.z = Sep; trussGroup.add(cage);
            sc.add(trussGroup); meshes.arch_struct = trussGroup;

        } else {
            // --- LOGIQUE SPÃ‰CIFIQUE NEWTON 3D CORRIGÃ‰E ---
            var Sep = visualSep; // Utilisation de la sÃ©paration calculÃ©e
            var D2 = currentData.D2; // Petit axe
            
            // Miroir Secondaire (Plan 45Â°)
            // Elliptique : Petit axe D2, Grand axe D2*sqrt(2)
            // Cylinder gÃ©nÃ¨re un cercle. On scale un axe.
            // Cylinder along Y. Cap in XZ.
            // On veut Ã©tirer selon l'axe qui sera projetÃ© : Z.
            var m2Geo = new THREE.CylinderGeometry(D2/2, D2/2, 2, 32);
            var m2Mat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness:0.9, roughness:0.1 });
            var m2 = new THREE.Mesh(m2Geo, m2Mat);
            m2.position.z = Sep;
            m2.rotation.x = -Math.PI/4; // Face au primaire, renvoi vers +Y
            m2.scale.z = 1.414; // Elongation pour projection circulaire
            sc.add(m2); meshes.arch_m2 = m2;

            // Rayons Newton (EntrÃ©e -> M1 -> M2 (intercepte cÃ´ne) -> Sortie LatÃ©rale)
            var numRays = 16; var ptsAll = [];
            var Z_start = Sep + 500; var Z_m1 = thick1; var Z_m2 = Sep; 
            var tubeR = R1*1.1; // Rayon approx du tube
            var Y_exit = tubeR + currentData.B; // Sortie sur axe Y (Foyer)

            // Ratio de rÃ©duction du cÃ´ne au niveau de M2
            // Focale = F1. Distance M1->M2 = Sep.
            // Ratio = (F1 - Sep) / F1;
            // Pour Ãªtre prÃ©cis, Sep est la distance depuis le sommet du primaire (approx Z=0)
            // Donc distance restante = F1 - Sep.
            var ratio = Math.max(0, (currentData.F1 - Sep) / currentData.F1);

            for(let i=0; i<numRays; i++) {
                var angle = (i/numRays) * Math.PI * 2;
                var x = Math.cos(angle) * R1; var y = Math.sin(angle) * R1;
                
                // CoordonnÃ©es d'impact sur le plan transversal de M2 (avant reflection)
                var xi = x * ratio;
                var yi = y * ratio;

                // EntrÃ©e -> M1
                ptsAll.push(new THREE.Vector3(x, y, Z_start)); ptsAll.push(new THREE.Vector3(x, y, Z_m1));
                
                // M1 -> M2 (Impact sur le bord du secondaire, pas le centre)
                ptsAll.push(new THREE.Vector3(x, y, Z_m1)); ptsAll.push(new THREE.Vector3(xi, yi, Z_m2));
                
                // M2 -> Sortie (+Y) (Convergence vers le foyer unique)
                // Ici on simplifie visuellement : les rayons rebondissent et vont vers le foyer.
                ptsAll.push(new THREE.Vector3(xi, yi, Z_m2)); ptsAll.push(new THREE.Vector3(0, Y_exit, Z_m2));
            }
            var lRays = new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(ptsAll), new THREE.LineBasicMaterial({ color: 0xaa00ff, opacity: 0.6, transparent: true }));
            sc.add(lRays); meshes.arch_rays = lRays;

            // Tube Plein
            var tubeGeo = new THREE.CylinderGeometry(tubeR, tubeR, Sep + 100, 32, 1, true);
            var tubeMat = new THREE.MeshStandardMaterial({color: 0x222222, side: THREE.DoubleSide, opacity:0.3, transparent:true});
            var tube = new THREE.Mesh(tubeGeo, tubeMat);
            tube.rotation.x = Math.PI/2;
            tube.position.z = Sep/2;
            sc.add(tube); meshes.arch_struct = tube;

            // Porte Oculaire + Camera
            var focGeo = new THREE.CylinderGeometry(25, 25, currentData.B, 16); // Porte oculaire
            var focMat = new THREE.MeshStandardMaterial({color: 0x111111});
            var foc = new THREE.Mesh(focGeo, focMat);
            foc.position.set(0, tubeR + currentData.B/2, Sep);
            sc.add(foc);
            meshes.arch_foc = foc; // NEW: Track focuser mesh

            var camRad = 35; var camLen = 40; 
            var camGeo = new THREE.CylinderGeometry(camRad, camRad, camLen, 32);
            var camMat = new THREE.MeshStandardMaterial({color: 0xcc0000, metalness:0.6, roughness:0.2});
            var cam = new THREE.Mesh(camGeo, camMat);
            // La camÃ©ra est posÃ©e sur le porte oculaire, axe Y
            cam.position.set(0, tubeR + currentData.B + camLen/2, Sep);
            sc.add(cam); meshes.arch_cam = cam;
        }
    }

    // INIT
    window.addEventListener('DOMContentLoaded', () => {
        var cvs = document.getElementById('blueprint-canvas');
        if(cvs) {
            cvs.addEventListener('mousedown', (e) => { viewState.isDragging = true; viewState.lastX = e.clientX; viewState.lastY = e.clientY; });
            window.addEventListener('mouseup', () => { viewState.isDragging = false; });
            cvs.addEventListener('mousemove', (e) => {
                if (!viewState.isDragging) return;
                viewState.offsetX += e.clientX - viewState.lastX; viewState.offsetY += e.clientY - viewState.lastY;
                viewState.lastX = e.clientX; viewState.lastY = e.clientY; window.redrawCurrentBlueprint();
            });
            cvs.addEventListener('wheel', (e) => { e.preventDefault(); window.zoomBlueprint(e.deltaY > 0 ? -0.1 : 0.1); });
        }
        window.autoCalcZones();
        setTimeout(window.runArchitect, 200); 
    });
</script>
</body>
</html>
