<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OPTICAL SUITE // JB. ANDRIVET</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-dark: #0f1218;
            --panel-bg: rgba(20, 25, 35, 0.95);
            --border: rgba(255, 255, 255, 0.15);
            --accent: #00bcd4; /* Cyan ing√©nieur */
            --accent-sec: #ff9800; /* Orange alerte */
            --text-main: #e0e0e0;
            --text-dim: #909090;
        }

        body {
            background-color: var(--bg-dark);
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 20px 20px;
            color: var(--text-main);
            font-family: 'Rajdhani', sans-serif;
            margin: 0; padding: 20px;
            height: 100vh; overflow: hidden;
            display: flex; flex-direction: column;
        }

        /* HEADER */
        .header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 20px; border-bottom: 1px solid var(--border); margin-bottom: 20px; }
        .brand { font-family: 'Orbitron'; font-size: 1.8rem; letter-spacing: 2px; }
        .brand span { color: var(--accent); font-weight: bold; }
        
        .nav { display: flex; gap: 5px; }
        .nav-btn {
            background: rgba(0,0,0,0.3); border: 1px solid var(--border); color: var(--text-dim);
            padding: 10px 20px; font-family: 'Orbitron'; cursor: pointer; transition: 0.2s;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }
        .nav-btn.active { background: var(--accent); color: #000; font-weight: bold; border-color: var(--accent); }

        /* MAIN LAYOUT */
        .container { display: none; height: 100%; gap: 20px; grid-template-columns: 320px 1fr; }
        .container.active { display: grid; }
        #course.container.active { display: block; overflow-y: auto; max-width: 900px; margin: 0 auto; }

        /* SIDEBAR CONTROLS */
        .sidebar { background: var(--panel-bg); border: 1px solid var(--border); padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 15px; }
        
        .group { display: flex; flex-direction: column; gap: 5px; margin-bottom: 10px; }
        .group label { font-size: 0.75rem; color: var(--accent); text-transform: uppercase; letter-spacing: 1px; display: flex; justify-content: space-between; }
        
        input, select {
            background: rgba(0,0,0,0.4); border: 1px solid var(--border); color: #fff;
            padding: 8px; font-family: 'Orbitron'; font-size: 0.9rem; width: 100%;
        }
        input:focus { border-color: var(--accent); outline: none; }
        input:disabled { opacity: 0.5; cursor: not-allowed; }

        /* MODE SWITCHER (ex: Fix F1, Auto...) */
        .mode-switch { display: flex; background: rgba(0,0,0,0.5); padding: 3px; border-radius: 4px; margin-bottom: 10px; }
        .mode-opt { flex: 1; text-align: center; padding: 6px; font-size: 0.65rem; cursor: pointer; color: var(--text-dim); font-family: 'Orbitron'; transition:0.2s; }
        .mode-opt.active { background: var(--accent); color: #000; font-weight: bold; }

        .btn-main { background: var(--accent); color: #000; font-weight: bold; padding: 12px; border: none; font-family: 'Orbitron'; cursor: pointer; margin-top: auto; text-transform: uppercase; }
        .btn-main:hover { box-shadow: 0 0 15px var(--accent); }
        .btn-sec { background: transparent; border: 1px solid var(--accent); color: var(--accent); padding: 8px; cursor: pointer; font-family: 'Orbitron'; font-size: 0.8rem; margin-top: 10px; }
        .btn-sec:hover { background: rgba(0, 188, 212, 0.1); }

        /* VIEWPORT */
        .viewport { display: flex; flex-direction: column; gap: 20px; overflow-y: auto; padding-right: 5px; }
        
        .viz-window {
            height: 500px; background: #fff; border: 1px solid var(--border); position: relative;
            display: flex; flex-direction: column;
        }
        .viz-window canvas { width: 100%; height: 100%; display: block; }
        
        .viz-tools {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 5px; background: rgba(255,255,255,0.9); padding: 5px; border-radius: 4px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .tool-btn { border: 1px solid #ccc; background: #fff; color: #333; padding: 5px 10px; font-size: 0.7rem; font-family: 'Orbitron'; cursor: pointer; }
        .tool-btn:hover { background: var(--accent); border-color: var(--accent); }
        .zoom-controls { position: absolute; bottom: 20px; right: 20px; display: flex; gap: 5px; }
        .zoom-btn { width: 30px; height: 30px; background: rgba(0,0,0,0.1); color: #000; border: 1px solid #000; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .zoom-btn:hover { background: #000; color: #fff; }

        .viz-tabs { display: flex; gap: 5px; position: absolute; top: 10px; right: 10px; }
        .viz-tab { padding: 5px 15px; background: rgba(0,0,0,0.7); color: #fff; border: 1px solid rgba(255,255,255,0.2); cursor: pointer; font-family: 'Orbitron'; font-size: 0.8rem; }
        .viz-tab.active { background: var(--accent); color: #000; font-weight: bold; border-color: var(--accent); }

        /* DATA TABLES */
        .info-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 20px; }
        .info-card { background: var(--panel-bg); border: 1px solid var(--border); padding: 15px; text-align: center; }
        .info-label { font-size: 0.7rem; color: var(--text-dim); margin-bottom: 5px; text-transform: uppercase; }
        .info-val { font-family: 'Orbitron'; font-size: 1.2rem; color: #fff; }

        .specs-table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
        .specs-table th { text-align: left; color: var(--accent); padding: 10px; border-bottom: 1px solid var(--border); }
        .specs-table td { padding: 10px; border-bottom: 1px solid rgba(255,255,255,0.05); }

        /* COURSE */
        .course-wrapper h1 { color: var(--accent); font-family: 'Orbitron'; border-bottom: 1px solid var(--border); padding-bottom: 20px; }
        .course-wrapper h2 { color: var(--accent-sec); margin-top: 40px; font-family: 'Orbitron'; }
        .formula { background: rgba(0,0,0,0.3); border-left: 3px solid var(--accent); padding: 15px; font-family: monospace; color: #fff; margin: 20px 0; }
        
        /* FOOTER */
        .footer { position: fixed; bottom: 5px; right: 20px; font-size: 0.7rem; color: rgba(255,255,255,0.2); font-family: 'Orbitron'; }
    </style>
</head>
<body>

    <div class="header">
        <div class="brand">JEAN-BAPTISTE <span>ANDRIVET</span></div>
        <div class="nav">
            <div class="nav-btn active" onclick="app.tab('analyzer')">ANALYSEUR CAUSTIQUE</div>
            <div class="nav-btn" onclick="app.tab('architect')">ARCHITECTE OPTIQUE</div>
            <div class="nav-btn" onclick="app.tab('course')">COURS</div>
        </div>
    </div>

    <div id="analyzer" class="container active">
        <div class="sidebar">
            <div class="group">
                <label>TYPE SURFACE</label>
                <select id="an-type" onchange="analyzer.updateK()">
                    <option value="parabola">Parabole (K=-1)</option>
                    <option value="sphere">Sph√®re (K=0)</option>
                    <option value="hyperbola">Hyperbole</option>
                    <option value="custom">Personnalis√©</option>
                </select>
            </div>
            <div class="group"><label>DIAM√àTRE (mm)</label><input type="number" id="an-D" value="300" oninput="analyzer.calc()"></div>
            <div class="group"><label>√âPAISSEUR (mm)</label><input type="number" id="an-thick" value="35" oninput="analyzer.calc()"></div>
            <div class="group"><label>TROU CENTRAL (mm)</label><input type="number" id="an-hole" value="0" oninput="analyzer.calc()"></div>
            
            <div class="group">
                <label>COURBURE 
                    <div class="mode-switch" style="margin:0; width:100px;">
                        <div class="mode-opt active" id="mode-R" onclick="analyzer.setMode('R')">RAYON</div>
                        <div class="mode-opt" id="mode-F" onclick="analyzer.setMode('F')">FOCALE</div>
                    </div>
                </label>
                <input type="number" id="an-curv" value="6000" oninput="analyzer.calc()">
            </div>
            
            <div class="group"><label>CONSTANTE (K)</label><input type="number" id="an-K" value="-1" disabled oninput="analyzer.calc()"></div>

            <div style="border-top:1px solid var(--border); padding-top:10px; margin-top:10px;">
                <label style="color:var(--text-dim); margin-bottom:5px;">MASQUE DE COUDER</label>
                <div class="group"><label>LISTE RAYONS (mm)</label><input type="text" id="an-zones" value="50, 100, 140" onchange="analyzer.calc()"></div>
                <button class="btn-sec" onclick="analyzer.autoZones()">CALCUL AUTO ZONES</button>
            </div>
        </div>

        <div class="viewport">
            <div class="info-grid">
                <div class="info-card"><div class="info-label">OUVERTURE</div><div class="info-val" id="an-res-fd">-</div></div>
                <div class="info-card"><div class="info-label">FL√àCHE MAX</div><div class="info-val" id="an-res-sag">-</div></div>
                <div class="info-card"><div class="info-label">POIDS (Z√©r.)</div><div class="info-val" id="an-res-weight">-</div></div>
                <div class="info-card"><div class="info-label">FOCUS LONG.</div><div class="info-val" id="an-res-ylong">-</div></div>
            </div>

            <div class="viz-window">
                <div class="viz-tabs">
                    <div class="viz-tab active" id="vt-an-2d" onclick="analyzer.setViz('2d')">2D TECH</div>
                    <div class="viz-tab" id="vt-an-3d" onclick="analyzer.setViz('3d')">3D MODEL</div>
                </div>
                
                <canvas id="cvs-an-2d"></canvas>
                <div id="cvs-an-3d" style="display:none; width:100%; height:100%;"></div>

                <div class="viz-tools" id="tools-an-3d" style="display:none;">
                    <div class="tool-btn" onclick="analyzer.cam('default')">RECADRER</div>
                    <div class="tool-btn" onclick="analyzer.cam('front')">FACE</div>
                    <div class="tool-btn" onclick="analyzer.cam('side')">PROFIL</div>
                </div>
            </div>

            <table class="specs-table">
                <thead><tr><th>ZONE</th><th>RAYON (Hm)</th><th>LONGITUDINAL (Y)</th><th>TRANSVERSAL (X)</th></tr></thead>
                <tbody id="an-table"></tbody>
            </table>
        </div>
    </div>

    <div id="architect" class="container">
        <div class="sidebar">
            <div class="group">
                <label>ARCHITECTURE</label>
                <select id="arch-type" onchange="architect.updateUI()">
                    <option value="newton">Newton</option>
                    <option value="cassegrain">Cassegrain</option>
                    <option value="dk">Dall-Kirkham</option>
                    <option value="rc" selected>Ritchey-Chr√©tien</option>
                    <option value="nasmyth">Nasmyth</option>
                    <option value="sct">Schmidt-Cassegrain</option>
                </select>
            </div>
            <div class="group"><label>DIAM√àTRE (mm)</label><input type="number" id="arch-D" value="400"></div>
            <div class="group"><label>BACK FOCUS (mm)</label><input type="number" id="arch-B" value="250"></div>
            <div class="group"><label>FOCALE SYST√àME (mm)</label><input type="number" id="arch-F" value="3200"></div>

            <label style="margin-top:15px;">MODE DE CALCUL</label>
            <div class="mode-switch">
                <div class="mode-opt active" id="am-f1" onclick="architect.setMode('f1')">FIGER F1</div>
                <div class="mode-opt" id="am-sep" onclick="architect.setMode('sep')">FIGER SEP</div>
                <div class="mode-opt" id="am-auto" onclick="architect.setMode('auto')">AUTO</div>
                <div class="mode-opt" id="am-man" onclick="architect.setMode('man')">MANUEL</div>
            </div>

            <div class="group"><label>FOCALE PRIMAIRE (F1) <span id="lock-f1">üîí</span></label><input type="number" id="arch-F1" value="1400"></div>
            <div class="group"><label>S√âPARATION (d) <span id="lock-sep" style="display:none">üîí</span></label><input type="number" id="arch-Sep" value="1000" disabled></div>

            <button class="btn-main" onclick="architect.calc()">CALCULER</button>
            <button class="btn-sec" onclick="architect.pdf()">EXPORTER PDF</button>
        </div>

        <div class="viewport">
            <div class="info-grid">
                <div class="info-card"><div class="info-label">OUVERTURE</div><div class="info-val" id="ar-res-fd">-</div></div>
                <div class="info-card"><div class="info-label">OBSTRUCTION</div><div class="info-val" id="ar-res-obs">-</div></div>
                <div class="info-card"><div class="info-label">GR. (M)</div><div class="info-val" id="ar-res-mag">-</div></div>
                <div class="info-card"><div class="info-label">R√âSOLUTION</div><div class="info-val" id="ar-res-res">-</div></div>
            </div>

            <div class="viz-window">
                <div class="viz-tabs">
                    <div class="viz-tab active" id="vt-ar-2d" onclick="architect.setViz('2d')">PLAN 2D</div>
                    <div class="viz-tab" id="vt-ar-3d" onclick="architect.setViz('3d')">SYST√àME 3D</div>
                </div>
                <canvas id="cvs-ar-2d"></canvas>
                <div id="cvs-ar-3d" style="display:none; width:100%; height:100%;"></div>
                
                <div class="zoom-controls" id="zoom-controls-2d" style="display:flex;">
                    <div class="zoom-btn" onclick="architect.zoom(0.1)">+</div>
                    <div class="zoom-btn" onclick="architect.zoom(-0.1)">-</div>
                    <div class="zoom-btn" onclick="architect.zoomReset()">R</div>
                </div>

                <div class="viz-tools" id="tools-ar-3d" style="display:none;">
                    <div class="tool-btn" onclick="architect.cam('default')">VUE D'ENSEMBLE</div>
                    <div class="tool-btn" onclick="architect.cam('side')">COUPE</div>
                    <div class="tool-btn" onclick="architect.cam('front')">FACE</div>
                </div>
            </div>

            <div style="display:flex; gap:20px;">
                <div style="flex:1; background:rgba(255,255,255,0.05); padding:15px; border:1px solid var(--border);">
                    <h4 style="margin:0 0 10px 0; color:var(--accent);">MIROIR PRIMAIRE</h4>
                    <table class="specs-table" style="font-size:0.8rem;">
                        <tr><td>Rayon (R1)</td><td id="t-r1">-</td></tr>
                        <tr><td>Constante (K1)</td><td id="t-k1">-</td></tr>
                        <tr><td>Forme</td><td id="t-s1">-</td></tr>
                    </table>
                </div>
                <div style="flex:1; background:rgba(255,255,255,0.05); padding:15px; border:1px solid var(--border);">
                    <h4 style="margin:0 0 10px 0; color:var(--accent-sec);">MIROIR SECONDAIRE</h4>
                    <table class="specs-table" style="font-size:0.8rem;">
                        <tr><td>Rayon (R2)</td><td id="t-r2">-</td></tr>
                        <tr><td>Constante (K2)</td><td id="t-k2">-</td></tr>
                        <tr><td>Diam√®tre Utile</td><td id="t-d2">-</td></tr>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <div id="course" class="container course-wrapper">
        <h1>MANUEL OPTIQUE AVANC√â</h1>
        <p>D√©velopp√© par Jean-Baptiste Andrivet, ce module int√®gre les √©quations corrig√©es pour la fabrication et le design.</p>

        <h2>1. ANALYSE CAUSTIQUE (PLATZECK-GAVIOLA)</h2>
        <p>Lorsqu'un miroir asph√©rique est test√© au centre de courbure, les rayons ne convergent pas en un point unique. Ils forment une caustique.  Pour le test de Foucault, nous devons d√©placer la source et le couteau selon les coordonn√©es X (Transversal) et Y (Longitudinal).</p>
        <div class="formula">
            Y = -K * z * [3 + c*z*(K+1)*(c*z*(K+1)-3)]<br>
            X = -S * c * K * z * [2 + ... ] / (1 - ...)
        </div>
        <p><i>Note : Le logiciel utilise les √©quations exactes de Cornejo & Malacara (1978), plus pr√©cises que l'approximation de Texereau pour les miroirs tr√®s ouverts (f/3).</i></p>

        <h2>2. ARCHITECTURE & CONSTANTES CONIQUES</h2>
        <p>Le module Architecte r√©sout les √©quations de Schwarzschild du 3√®me ordre pour annuler l'aberration sph√©rique et la coma.</p>
        
        <h3>Ritchey-Chr√©tien (RC)</h3>
        <p>Standard professionnel. Deux miroirs hyperboliques. Le syst√®me est aplan√©tique (pas de coma).</p>
        
        <div class="formula">
            K1 = -1 - (2 * (F1 * M - Sep)) / (M^3 * (F1 - Sep))<br>
            K2 = -((M+1)/(M-1))^2 ...
        </div>

        <h3>Dall-Kirkham (DK)</h3>
        <p>Secondaire sph√©rique (K2=0). Le primaire est une ellipse prolate. Excellent sur l'axe, mais coma importante hors axe.</p>

        <h3>Nasmyth</h3>
        <p>Identique optiquement au Cassegrain ou RC, mais avec un miroir plan tertiaire (M3) renvoyant le faisceau lat√©ralement travers l'axe de d√©clinaison.</p>
    </div>

    <div class="footer">JB. ANDRIVET ENGINEERING // V.7.2.1</div>

<script>
// === CORE SYSTEM ===
const app = {
    tab: (id) => {
        document.querySelectorAll('.container').forEach(e => e.classList.remove('active'));
        document.getElementById(id).classList.add('active');
        document.querySelectorAll('.nav-btn').forEach(e => e.classList.remove('active'));
        event.target.classList.add('active');
        if(id === 'analyzer') analyzer.calc();
        if(id === 'architect') architect.calc();
    }
};

// === ANALYZER MODULE ===
const analyzer = {
    mode: 'R', // R or F
    vizMode: '2d',
    scene: null,

    setMode: (m) => {
        analyzer.mode = m;
        document.querySelectorAll('#analyzer .mode-opt').forEach(e => e.classList.remove('active'));
        document.getElementById('mode-'+m).classList.add('active');
        const inp = document.getElementById('an-curv');
        const val = parseFloat(inp.value);
        inp.value = (m === 'F') ? val/2 : val*2;
        analyzer.calc();
    },

    setViz: (v) => {
        analyzer.vizMode = v;
        document.getElementById('vt-an-2d').classList.toggle('active', v==='2d');
        document.getElementById('vt-an-3d').classList.toggle('active', v==='3d');
        document.getElementById('cvs-an-2d').style.display = v==='2d'?'block':'none';
        document.getElementById('cvs-an-3d').style.display = v==='3d'?'block':'none';
        document.getElementById('tools-an-3d').style.display = v==='3d'?'flex':'none';
        if(v==='2d') analyzer.draw2D(); else analyzer.draw3D();
    },

    updateK: () => {
        const t = document.getElementById('an-type').value;
        const k = document.getElementById('an-K');
        k.disabled = (t !== 'custom');
        if(t==='parabola') k.value = -1;
        if(t==='sphere') k.value = 0;
        if(t==='hyperbola') k.value = -1.1;
        analyzer.calc();
    },

    autoZones: () => {
        const D = parseFloat(document.getElementById('an-D').value);
        if(!D) return;
        // Couder logic approx
        let zs = [];
        const n = 4; // 4 zones standard demo
        const Rmax = D/2;
        for(let i=1; i<=n; i++) {
            let rOuter = Rmax * Math.sqrt(i/n);
            let rInner = Rmax * Math.sqrt((i-1)/n);
            zs.push( ((rOuter+rInner)/2).toFixed(1) );
        }
        document.getElementById('an-zones').value = zs.join(', ');
        analyzer.calc();
    },

    calc: () => {
        const D = parseFloat(document.getElementById('an-D').value);
        const thick = parseFloat(document.getElementById('an-thick').value);
        const hole = parseFloat(document.getElementById('an-hole').value) || 0;
        const cVal = parseFloat(document.getElementById('an-curv').value);
        const K = parseFloat(document.getElementById('an-K').value);
        
        if(!D || !cVal) return;

        const R = (analyzer.mode === 'F') ? cVal * 2 : cVal;
        const F = R/2;
        const zones = document.getElementById('an-zones').value.split(',').map(Number).filter(n => n>0);

        // Physics
        const sag = (D*D)/(8*R); // Approx
        const vol = (Math.PI * (D/2)**2 * thick) - (Math.PI * (hole/2)**2 * thick); 
        const weight = (vol / 1000) * 0.00253; // Zerodur density

        // UI Updates
        document.getElementById('an-res-fd').innerText = "f/" + (F/D).toFixed(1);
        document.getElementById('an-res-sag').innerText = sag.toFixed(2) + " mm";
        document.getElementById('an-res-weight').innerText = weight.toFixed(2) + " kg";

        // Caustic Math (Cornejo & Malacara)
        const tbody = document.getElementById('an-table');
        tbody.innerHTML = "";
        let maxY = 0;

        zones.forEach((S, i) => {
            if(S > D/2) return;
            const c = 1/R;
            const term = 1 - (K+1)*c*c*S*S;
            if(term < 0) return; // Err
            
            const z = (c*S*S) / (1 + Math.sqrt(term)); 
            const A = c*z*(K+1);
            const Y = -K*z*(3 + A*(A-3));
            const X = Math.abs( (-S*c*K*z*(2 + A*(A-3))) / (1-A) );
            
            if(Math.abs(Y) > maxY) maxY = Math.abs(Y);

            tbody.innerHTML += `<tr>
                <td style="color:var(--accent)">Zone ${i+1}</td>
                <td>${S}</td>
                <td>${Y.toFixed(3)}</td>
                <td style="font-weight:bold">${X.toFixed(3)}</td>
            </tr>`;
        });
        document.getElementById('an-res-ylong').innerText = maxY.toFixed(2) + " mm";
        
        analyzer.data = { D, R, thick, hole, zones, K };
        if(analyzer.vizMode === '2d') analyzer.draw2D(); else analyzer.draw3D();
    },

    draw2D: () => {
        const cvs = document.getElementById('cvs-an-2d');
        const ctx = cvs.getContext('2d');
        const w = cvs.width = cvs.parentElement.offsetWidth;
        const h = cvs.height = cvs.parentElement.offsetHeight;
        const d = analyzer.data;
        
        ctx.fillStyle = "#fff"; ctx.fillRect(0,0,w,h);
        
        // Split view: Left = Face, Right = Profile (Coupe)
        const cx1 = w*0.3; const cy = h/2;
        const cx2 = w*0.75; 
        const scale = (h*0.8) / d.D;

        // FACE
        ctx.beginPath(); ctx.arc(cx1, cy, (d.D/2)*scale, 0, Math.PI*2);
        ctx.fillStyle = "#eee"; ctx.fill(); ctx.strokeStyle="#333"; ctx.lineWidth=2; ctx.stroke();
        if(d.hole>0) {
            ctx.beginPath(); ctx.arc(cx1, cy, (d.hole/2)*scale, 0, Math.PI*2);
            ctx.fillStyle = "#fff"; ctx.fill(); ctx.stroke();
        }
        d.zones.forEach(z => {
            ctx.beginPath(); ctx.arc(cx1, cy, z*scale, 0, Math.PI*2);
            ctx.strokeStyle = "rgba(0,188,212,0.5)"; ctx.lineWidth=1; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
        });
        ctx.fillStyle="#000"; ctx.fillText("VUE DE FACE", cx1-30, h-20);

        // PROFILE (Coupe)
        // Draw wedge shape
        const sagScale = 10; // Exaggerate curve
        ctx.beginPath();
        // Back flat
        ctx.moveTo(cx2, cy - (d.D/2)*scale);
        ctx.lineTo(cx2 + d.thick*scale, cy - (d.D/2)*scale);
        ctx.lineTo(cx2 + d.thick*scale, cy + (d.D/2)*scale);
        ctx.lineTo(cx2, cy + (d.D/2)*scale);
        // Curve
        for(let i=0; i<=20; i++) {
            let r = (d.D/2) * (1 - i/20) * (i<10 ? -1:1); // Top to bottom? No, simpler
        }
        ctx.closePath(); 
        
        // Simple rectangular representation with curve cutout
        ctx.fillStyle = "#ddd"; ctx.strokeStyle = "#333";
        ctx.fillRect(cx2, cy - (d.D/2)*scale, d.thick*scale, d.D*scale);
        
        // Draw curve overlay
        ctx.beginPath();
        ctx.moveTo(cx2, cy - (d.D/2)*scale);
        for(let y = -(d.D/2); y <= (d.D/2); y+= (d.D/20)) {
            let r = Math.abs(y);
            let z = (r*r)/(2*d.R); // Parabolic approx
            ctx.lineTo(cx2 + z*scale*sagScale, cy + y*scale);
        }
        ctx.strokeStyle = "var(--accent-sec)"; ctx.lineWidth=2; ctx.stroke();
        ctx.fillStyle="#000"; ctx.fillText("PROFIL (Sag x10)", cx2, h-20);
    },

    draw3D: () => {
        const cont = document.getElementById('cvs-an-3d');
        if(!analyzer.scene) {
            analyzer.scene = new THREE.Scene(); analyzer.scene.background = new THREE.Color(0x222222);
            analyzer.camObj = new THREE.PerspectiveCamera(45, cont.offsetWidth/cont.offsetHeight, 1, 10000);
            analyzer.camObj.position.set(0, 500, 800);
            analyzer.renderer = new THREE.WebGLRenderer({antialias:true});
            analyzer.renderer.setSize(cont.offsetWidth, cont.offsetHeight);
            cont.innerHTML = ""; cont.appendChild(analyzer.renderer.domElement);
            analyzer.controls = new THREE.OrbitControls(analyzer.camObj, analyzer.renderer.domElement);
            analyzer.scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const dl = new THREE.DirectionalLight(0xffffff, 1); dl.position.set(500,500,500); analyzer.scene.add(dl);
        }

        while(analyzer.scene.children.length > 2) analyzer.scene.remove(analyzer.scene.children[2]);

        const d = analyzer.data;
        const pts = [];
        const seg = 60;
        // Profile
        pts.push(new THREE.Vector2(d.hole/2, 0));
        pts.push(new THREE.Vector2(d.D/2, 0));
        pts.push(new THREE.Vector2(d.D/2, d.thick));
        for(let i=seg; i>=0; i--) {
            let r = (d.hole/2) + (i/seg)*((d.D/2)-(d.hole/2));
            let s = (r*r)/(2*d.R); // approx
            let edgeS = ((d.D/2)**2)/(2*d.R);
            pts.push(new THREE.Vector2(r, d.thick - (edgeS - s)));
        }
        const geo = new THREE.LatheGeometry(pts, 64);
        const mat = new THREE.MeshStandardMaterial({color:0xaaaaaa, roughness:0.2, metalness:0.6});
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = -Math.PI/2;
        analyzer.scene.add(mesh);
        
        analyzer.renderer.render(analyzer.scene, analyzer.camObj);
    },

    cam: (view) => {
        const c = analyzer.camObj;
        const ctr = analyzer.controls;
        ctr.reset();
        if(view === 'default') c.position.set(0, 500, 800);
        if(view === 'front') c.position.set(0, 1000, 0);
        if(view === 'side') c.position.set(1000, 0, 0);
        c.lookAt(0,0,0);
        analyzer.renderer.render(analyzer.scene, analyzer.camObj);
    }
};

// === ARCHITECT MODULE ===
const architect = {
    mode: 'f1', // f1, sep, auto, man
    viz: '2d',
    viewState: { scale: 1, offsetX: 0, offsetY: 0, isDragging: false, lastX: 0, lastY: 0 },
    
    setMode: (m) => {
        architect.mode = m;
        document.querySelectorAll('#architect .mode-opt').forEach(e => e.classList.remove('active'));
        document.getElementById('am-'+m).classList.add('active');
        
        const f1 = document.getElementById('arch-F1');
        const sep = document.getElementById('arch-Sep');
        const f = document.getElementById('arch-F');

        // Reset
        f1.disabled = false; sep.disabled = false; f.disabled = false;
        document.getElementById('lock-f1').style.display='none';
        document.getElementById('lock-sep').style.display='none';

        if(m === 'f1') {
            sep.disabled = true; document.getElementById('lock-f1').style.display='inline';
        } else if (m === 'sep') {
            f1.disabled = true; document.getElementById('lock-sep').style.display='inline';
        } else if (m === 'auto') {
            f1.disabled = true; sep.disabled = true;
        } else if (m === 'man') {
            f.disabled = true; // Manual overrides F_sys result
        }
        architect.calc();
    },

    setViz: (v) => {
        architect.viz = v;
        document.getElementById('vt-ar-2d').classList.toggle('active', v==='2d');
        document.getElementById('vt-ar-3d').classList.toggle('active', v==='3d');
        document.getElementById('cvs-ar-2d').style.display = v==='2d'?'block':'none';
        document.getElementById('cvs-ar-3d').style.display = v==='3d'?'block':'none';
        document.getElementById('tools-ar-3d').style.display = v==='3d'?'flex':'none';
        document.getElementById('zoom-controls-2d').style.display = v==='2d'?'flex':'none';
        if(v==='2d') architect.draw2D(); else architect.draw3D();
    },
    
    zoom: (delta) => {
        architect.viewState.scale += delta;
        if(architect.viewState.scale < 0.1) architect.viewState.scale = 0.1;
        architect.draw2D();
    },
    
    zoomReset: () => {
        architect.viewState.scale = 1; architect.viewState.offsetX = 0; architect.viewState.offsetY = 0;
        architect.draw2D();
    },

    updateUI: () => {
        // Newton handling
        const t = document.getElementById('arch-type').value;
        const isN = (t === 'newton');
        // If Newton, disable mode switch, enforce logic
        architect.calc();
    },

    calc: () => {
        const type = document.getElementById('arch-type').value;
        const D = parseFloat(document.getElementById('arch-D').value);
        const B = parseFloat(document.getElementById('arch-B').value);
        let F = parseFloat(document.getElementById('arch-F').value);
        
        // Mode handling inputs
        let F1 = parseFloat(document.getElementById('arch-F1').value);
        let Sep = parseFloat(document.getElementById('arch-Sep').value);

        if(type === 'newton') {
            // Newton Logic: F1 = F. Sep determined by tube radius + B.
            F1 = F; 
            document.getElementById('arch-F1').value = F;
            const tubeR = D/2 + 30; // approx
            Sep = F - (tubeR + B);
        } else {
            // Cassegrain types logic based on Mode
            if(architect.mode === 'auto') {
                F1 = D * 3; // Approx start
                document.getElementById('arch-F1').value = F1;
                const M = F/F1;
                Sep = (F1*M - B)/(M+1);
            } else if (architect.mode === 'f1') {
                const M = F/F1;
                Sep = (F1*M - B)/(M+1);
            } else if (architect.mode === 'sep') {
                // (F1 * (F/F1) - B) / ((F/F1)+1) = Sep  => complex to solve for F1
                // Easier: M = (Sep+B)/(F1-Sep). And F = F1*M.
                // Iterative or geometric solve.
                // Let's assume M is driven by geometry.
                // Actually if Sep is fixed and F is fixed:
                // F = F1 * (Sep+B)/(F1-Sep). Quadratic for F1.
                // F(F1 - Sep) = F1(Sep+B) => F*F1 - F*Sep = F1*Sep + F1*B
                // F1(F - Sep - B) = F*Sep => F1 = (F*Sep)/(F - Sep - B)
                F1 = (F*Sep)/(F - Sep - B);
                document.getElementById('arch-F1').value = F1.toFixed(1);
            } else if (architect.mode === 'man') {
                // Free F1 and Sep. Calculate F result.
                const M = (Sep+B)/(F1-Sep);
                F = F1 * M;
                document.getElementById('arch-F').value = F.toFixed(1);
            }
        }
        
        // Output Update for dependent values
        if(type !== 'newton' && architect.mode !== 'sep' && architect.mode !== 'man') {
             document.getElementById('arch-Sep').value = Sep.toFixed(1);
        }

        // --- MATHS (Schwarzschild & Co) ---
        const M = (type==='newton') ? 1 : F/F1;
        const R1 = F1 * 2;
        let K1 = -1; let R2 = 0; let K2 = 0;
        let s1 = "Parabole"; let s2 = "Plan";
        
        // Secondary Diameter (Geometric)
        let D2 = (type==='newton') ? (D * (F1-Sep)/F1) : (D*(F1-Sep)/F1);

        if(type === 'rc' || type === 'nasmyth') {
            // Ritchey Chretien
            // K1 = -1 - (2(Sep+B))/(M^3(F1-Sep))  (Approx)
            // Using correct code from previous iteration
            K1 = -1 - (2*(Sep+B))/(Math.pow(M,3)*Sep); // Simplified formula often used in code
            K2 = -Math.pow((M+1)/(M-1),2) - (4*M*(M+1))/((M-1)*Math.pow(M,2))*((Sep+B)/Sep);
            s1="Hyperbole"; s2="Hyperbole";
            R2 = (2*Sep*M)/(M-1);
        } else if (type === 'dk') {
            K2 = 0; s2="Sph√®re";
            const p = Sep + B;
            K1 = -1 + ((M*M-1)/(M*M*M))*(p/F1);
            s1="Ellipse";
            R2 = (2*Sep*M)/(M-1);
        } else if (type === 'cassegrain') {
            K1 = -1; s1="Parabole";
            K2 = -Math.pow((M+1)/(M-1),2); s2="Hyperbole";
            R2 = (2*Sep*M)/(M-1);
        } else if (type === 'sct') {
            K1 = 0; s1="Sph√®re"; // Actually handled by corrector
            K2 = 0; s2="Sph√®re";
            R2 = (2*Sep*M)/(M-1);
            // SCT usually M ~ 5.
        }

        // Save data
        architect.data = { type, D, F, F1, Sep, B, R1, K1, R2, K2, D2, s1, s2, M };

        // DOM Update
        document.getElementById('ar-res-fd').innerText = "f/" + (F/D).toFixed(1);
        document.getElementById('ar-res-mag').innerText = M.toFixed(2) + "x";
        document.getElementById('ar-res-obs').innerText = ((D2/D)*100).toFixed(1) + "%";
        document.getElementById('ar-res-res').innerText = (120/D).toFixed(2) + '"';

        document.getElementById('t-r1').innerText = R1.toFixed(1);
        document.getElementById('t-k1').innerText = K1.toFixed(3);
        document.getElementById('t-s1').innerText = s1;
        
        document.getElementById('t-r2').innerText = (type==='newton') ? "Inf" : R2.toFixed(1);
        document.getElementById('t-k2').innerText = K2.toFixed(3);
        document.getElementById('t-d2').innerText = D2.toFixed(1) + " mm";

        if(architect.viz === '2d') architect.draw2D(); else architect.draw3D();
    },

    draw2D: () => {
        const c = document.getElementById('cvs-ar-2d');
        const ctx = c.getContext('2d');
        c.width = c.parentElement.offsetWidth; c.height = c.parentElement.offsetHeight;
        const d = architect.data;
        const w = c.width; const h = c.height;

        ctx.clearRect(0,0,w,h);
        ctx.save();
        
        // Transform logic for Zoom/Pan
        ctx.translate(architect.viewState.offsetX, architect.viewState.offsetY);
        ctx.translate(w/2, h/2);
        ctx.scale(architect.viewState.scale, architect.viewState.scale);
        ctx.translate(-w/2, -h/2);

        // Scale
        const totalLen = Math.max(d.F1, d.Sep+d.B) * 1.2;
        const sc = (w-100) / totalLen;
        const x0 = 50; const y0 = h/2;

        // Axis
        ctx.strokeStyle = "#ddd"; ctx.setLineDash([5,5]);
        ctx.beginPath(); ctx.moveTo(0, y0); ctx.lineTo(w, y0); ctx.stroke(); ctx.setLineDash([]);

        // M1
        ctx.strokeStyle = "#00bcd4"; ctx.lineWidth = 3;
        ctx.beginPath();
        // Simple curve draw
        const r1px = (d.D/2)*sc;
        const sag1 = 10; // Visual
        ctx.moveTo(x0, y0-r1px); 
        ctx.quadraticCurveTo(x0-sag1, y0, x0, y0+r1px);
        ctx.stroke();

        // M2 position
        const x2 = x0 + d.Sep*sc;
        const r2px = (d.D2/2)*sc;
        
        // M2 Draw
        ctx.strokeStyle = "#ff9800";
        ctx.beginPath();
        if(d.type === 'newton') {
            ctx.moveTo(x2-r2px, y0-r2px); ctx.lineTo(x2+r2px, y0+r2px);
        } else {
            ctx.moveTo(x2, y0-r2px); 
            ctx.quadraticCurveTo(x2+3, y0, x2, y0+r2px);
        }
        ctx.stroke();

        // Rays & Baffles
        ctx.strokeStyle = "rgba(0,0,0,0.1)"; ctx.lineWidth = 1;
        // Incoming
        ctx.beginPath(); ctx.moveTo(w, y0-r1px); ctx.lineTo(x0, y0-r1px); ctx.stroke();
        
        // M1 -> M2
        // Intercept height at M2
        const hM2 = r1px * ((d.F1 - d.Sep)/d.F1); 
        ctx.beginPath(); ctx.moveTo(x0, y0-r1px); ctx.lineTo(x2, y0-hM2); ctx.stroke();

        // M2 -> Focus
        if(d.type === 'newton') {
             // Out top
             const fY = y0 - (d.B*sc + r1px + 20); // Outside tube
             ctx.beginPath(); ctx.moveTo(x2, y0-hM2); ctx.lineTo(x2, fY); ctx.stroke();
        } else if (d.type === 'nasmyth') {
             // M3
             const x3 = x0 + (d.Sep * 0.25)*sc;
             ctx.beginPath(); ctx.moveTo(x2, y0-hM2); ctx.lineTo(x3, y0); ctx.stroke(); // to M3
             // M3 visual
             ctx.strokeStyle = "#000"; ctx.lineWidth=2;
             ctx.beginPath(); ctx.moveTo(x3-10, y0+10); ctx.lineTo(x3+10, y0-10); ctx.stroke();
             // Out
             ctx.strokeStyle = "rgba(0,0,0,0.1)"; ctx.lineWidth=1;
             ctx.beginPath(); ctx.moveTo(x3, y0); ctx.lineTo(x3, y0 - (d.B*sc + r1px)); ctx.stroke();
        } else {
             // Standard back
             const xF = x0 - d.B*sc;
             ctx.beginPath(); ctx.moveTo(x2, y0-hM2); ctx.lineTo(xF, y0); ctx.stroke();
        }
        ctx.restore();
    },

    draw3D: () => {
        const cont = document.getElementById('cvs-ar-3d');
        if(!architect.scene) {
            architect.scene = new THREE.Scene(); architect.scene.background = new THREE.Color(0xdddddd);
            architect.camObj = new THREE.PerspectiveCamera(45, cont.offsetWidth/cont.offsetHeight, 1, 10000);
            architect.camObj.position.set(500, 500, 1000);
            architect.renderer = new THREE.WebGLRenderer({antialias:true});
            architect.renderer.setSize(cont.offsetWidth, cont.offsetHeight);
            cont.innerHTML = ""; cont.appendChild(architect.renderer.domElement);
            architect.controls = new THREE.OrbitControls(architect.camObj, architect.renderer.domElement);
            architect.scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        }

        while(architect.scene.children.length > 1) architect.scene.remove(architect.scene.children[1]);

        const d = architect.data;
        const mat = new THREE.MeshStandardMaterial({color:0x88ccff, metalness:0.9, roughness:0.1, side:THREE.DoubleSide});

        // M1
        const g1 = new THREE.CylinderGeometry(d.D/2, d.D/2, 20, 64);
        const m1 = new THREE.Mesh(g1, mat);
        m1.rotation.x = Math.PI/2;
        architect.scene.add(m1);

        // M2
        const g2 = new THREE.CylinderGeometry(d.D2/2, d.D2/2, 5, 32);
        const m2 = new THREE.Mesh(g2, mat);
        if(d.type==='newton') {
            m2.position.z = d.Sep;
            m2.rotation.x = -Math.PI/4;
            m2.scale.z = 1.414; 
        } else {
            m2.position.z = d.Sep;
            m2.rotation.x = Math.PI/2;
        }
        architect.scene.add(m2);
        
        // M3 (Nasmyth)
        if(d.type === 'nasmyth') {
            const m3pos = d.Sep * 0.25;
            const g3 = new THREE.CylinderGeometry(d.D2/2.5, d.D2/2.5, 5, 32);
            const m3 = new THREE.Mesh(g3, mat);
            m3.position.z = m3pos;
            // 45 deg tilt to reflect X
            m3.rotation.z = -Math.PI/2;
            m3.rotation.y = -Math.PI/4;
            m3.scale.z = 1.414;
            architect.scene.add(m3);
            
            // Camera/Focuser side
            const camGeo = new THREE.CylinderGeometry(20, 20, 50, 32);
            const cam = new THREE.Mesh(camGeo, new THREE.MeshStandardMaterial({color:0x333}));
            const exitX = d.B + m3pos;
            cam.position.set(exitX, 0, m3pos);
            cam.rotation.z = -Math.PI/2;
            architect.scene.add(cam);
        }

        // Structure (Truss)
        const trMat = new THREE.MeshBasicMaterial({color:0x333333, wireframe:true});
        const len = (d.type==='newton') ? d.F1 : d.Sep;
        const truss = new THREE.Mesh(new THREE.CylinderGeometry(d.D/2+20, d.D/2+20, len, 8, 1, true), trMat);
        truss.rotation.x = Math.PI/2;
        truss.position.z = len/2;
        architect.scene.add(truss);

        architect.renderer.render(architect.scene, architect.camObj);
    },

    cam: (v) => {
        const c = architect.camObj;
        architect.controls.reset();
        if(v==='default') c.position.set(500,500,1000);
        if(v==='side') c.position.set(1000,0,500); // 3/4 view
        if(v==='front') c.position.set(0,0,1500);
        c.lookAt(0,0,0);
        architect.renderer.render(architect.scene, c);
    },

    pdf: () => {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        const d = architect.data;
        doc.setFontSize(20); doc.text("RAPPORT OPTIQUE // JB. ANDRIVET", 20, 20);
        doc.setFontSize(12);
        let y = 40;
        doc.text(`Type: ${d.type.toUpperCase()}`, 20, y); y+=10;
        doc.text(`Diam√®tre: ${d.D} mm`, 20, y); y+=10;
        doc.text(`Focale: ${d.F.toFixed(1)} mm (f/${(d.F/d.D).toFixed(1)})`, 20, y); y+=10;
        doc.text(`Grandissement: ${d.M.toFixed(2)}x`, 20, y); y+=20;
        
        doc.text("Primaire:", 20, y); y+=10;
        doc.text(`R1: ${d.R1.toFixed(2)}  K1: ${d.K1.toFixed(4)}`, 30, y); y+=20;

        doc.text("Secondaire:", 20, y); y+=10;
        doc.text(`R2: ${d.R2.toFixed(2)}  K2: ${d.K2.toFixed(4)}`, 30, y); y+=10;
        doc.text(`S√©paration: ${d.Sep.toFixed(2)} mm`, 30, y);

        doc.save("Design_Optique.pdf");
    }
};

// Init
window.onload = () => { 
    app.tab('analyzer');
    // Zoom handler
    const cvs = document.getElementById('cvs-ar-2d');
    cvs.addEventListener('mousedown', (e) => { architect.viewState.isDragging = true; architect.viewState.lastX = e.clientX; architect.viewState.lastY = e.clientY; });
    window.addEventListener('mouseup', () => { architect.viewState.isDragging = false; });
    cvs.addEventListener('mousemove', (e) => {
        if (!architect.viewState.isDragging) return;
        architect.viewState.offsetX += e.clientX - architect.viewState.lastX; 
        architect.viewState.offsetY += e.clientY - architect.viewState.lastY;
        architect.viewState.lastX = e.clientX; architect.viewState.lastY = e.clientY; 
        architect.draw2D();
    });
};
</script>
</body>
</html>
